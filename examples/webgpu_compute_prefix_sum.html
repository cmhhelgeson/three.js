<html lang="en">
	<head>
		<title>three.js webgpu - storage pbo external element</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org" target="_blank" rel="noopener">three.js</a>
			<br /> Prefix sum performance comparisons.
			<br /> Each display loops through initialization, sum, and validation steps.
			<br/>
			<div id="local_swap" style="
				position: absolute;
				top: 150px;
				left: 0;
				padding: 10px;
				background: rgba( 0, 0, 0, 0.5 );
				color: #fff;
				font-family: monospace;
				font-size: 12px;
				line-height: 1.5;
				pointer-events: none;
				text-align: left;
			"></div>
			<div id="global_swap" style="
			position: absolute;
			top: 150px;
			right: 0;
			padding: 10px;
			background: rgba( 0, 0, 0, 0.5 );
			color: #fff;
			font-family: monospace;
			font-size: 12px;
			line-height: 1.5;
			pointer-events: none;
			text-align: left;
		"></div>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/tsl": "../build/three.webgpu.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three';
			import { If, vec3, uniform, uv, uint, float, Fn, vec2, uvec2, floor, instanceIndex, workgroupBarrier, atomicAdd, atomicStore, workgroupId, storage } from 'three/tsl';

			import { GUI } from 'three/addons/libs/lil-gui.module.min.js';

			const numElements = 256;

			const effectController = {
				// Sqr root of 16834
				gridWidth: uniform( Math.sqrt( numElements ) ),
				gridHeight: uniform( Math.sqrt( numElements ) ),
				validate: uniform( 0 ),
				'Left Display Algo': 'Fake Prefix',
				'Right Display Algo': 'Kogge-Stone (Favor Dispatch)',
			};

			const algorithms = [
				'Sklansky (Favor Dispatch)',
				'Kogge-Stone (Favor Dispatch)',
				'Fake Prefix',
				'Incorrect'
			];

			const gui = new GUI();

			//gui.add( effectController, 'Step' );
			gui.add( effectController, 'Left Display Algo', algorithms );
			gui.add( effectController, 'Right Display Algo', algorithms );

			// Initialize Two Views
			init( false );
			init( true );

			// When forceGlobalSwap is true, force all valid local swaps to be global swaps.
			async function init( rightSide ) {

				// Create prefix sort data
				const array = new Uint32Array( Array.from( { length: numElements }, ( _, i ) => {

					return i;

				} ) );

				const infoArray = new Uint32Array( 5 ).fill( 1 );

				const currentElementsBuffer = new THREE.StorageInstancedBufferAttribute( array, 1 );
				const currentElementsStorage = storage( currentElementsBuffer, 'uint', currentElementsBuffer.count ).label( 'Elements' );
				const infoBuffer = new THREE.StorageInstancedBufferAttribute( infoArray, 1 );
				const infoStorage = storage( infoBuffer, 'uint', infoBuffer.count );

				const initMethod = ( currentElements ) => {

					currentElements.element( instanceIndex ).assign( 1 );
			
				};

				// Define and compile prefix sum methods.
				const prefixSumMethods = {
					// Emulates a prefix sum by manually assigning the instanceIndex to the storage buffer.
					// This method should only be used to validate the correctness of new algorithms, and not as
					// a yardstick for performance.
					'Fake Prefix': {
						// # of values in the threads array indicates the number of dispatches
						threads: [ numElements ],
						runMethod: ( currentElements ) => {

							currentElements.element( instanceIndex ).assign( instanceIndex.add( 1 ) );
			
						},
					},
					// Emulates an incorrect prefix sum by manually assigning the instanceIndex's inverse value.
					// Used to demonstrate a completely incorrect algorithm
					'Incorrect': {
						threads: [ numElements ],
						runMethod: ( currentElements ) => {

							currentElements.element( instanceIndex ).assign( uint( numElements ).sub( instanceIndex ) );

						},
					},
					'Sklansky (Favor Dispatch)': {
						threads: Array( Math.log2( numElements ) ).fill( numElements / 2 ),
						runMethod: ( currentElements ) => {

			

			
						},
					},
					'Kogge-Stone (Favor Dispatch)': {
						threads: Array( Math.floor( Math.log2( numElements ) ) ).fill().map( ( _, idx ) => {

							return idx === 0 ? numElements : numElements - 2 ** idx;
			
						} ),
						initMethod: ( currentElements, info ) => {

							initMethod( currentElements );
							info.element( 0 ).assign( 1 );

						},
						runMethod: ( currentElements, info ) => {

							const offset = info.element( 0 );

							const baseValue = currentElements.element( instanceIndex );
							const offsetValue = currentElements.element( instanceIndex.add( offset ) );

							offsetValue.addAssign( baseValue );

							workgroupBarrier();

							If( instanceIndex.equal( numElements - 1 ), () => {

								info.element( 0 ).mulAssign( 2 );

							} );

						}
					}
				};


				// Pre-compile shaders
				for ( const key in prefixSumMethods ) {

					// Compile init function
					if ( prefixSumMethods[ key ].initMethod ) {

						prefixSumMethods[ key ].initFunction = Fn( () => {

							prefixSumMethods[ key ].initMethod( currentElementsStorage, infoStorage );

						} )().compute( numElements );

					} else {

						prefixSumMethods[ key ].initFunction = Fn( () => {

							initMethod( currentElementsStorage );

						} )().compute( numElements );

					}

					prefixSumMethods[ key ].runFunctions = [];

					const runFunctionTemplate = Fn( ( ) => {

						prefixSumMethods[ key ].runMethod( currentElementsStorage, infoStorage );

					} );

					for ( let i = 0; i < prefixSumMethods[ key ].threads.length; i ++ ) {

						prefixSumMethods[ key ].runFunctions.push( runFunctionTemplate().compute( prefixSumMethods[ key ].threads[ i ] ) );

			
					}

				}
			
				console.log( prefixSumMethods );

				// Create standard scene
				const aspect = ( window.innerWidth / 2 ) / window.innerHeight;
				const camera = new THREE.OrthographicCamera( - aspect, aspect, 1, - 1, 0, 2 );
				camera.position.z = 1;

				const scene = new THREE.Scene();

				const material = new THREE.MeshBasicNodeMaterial( { color: 0x00ff00 } );

				const display = Fn( () => {

					const { gridWidth, gridHeight } = effectController;
					const newUV = uv().mul( vec2( gridWidth, gridHeight ) );
					const pixel = uvec2( uint( floor( newUV.x ) ), uint( floor( newUV.y ) ) );
					const elementIndex = uint( gridWidth ).mul( pixel.y ).add( pixel.x );
					const colorChanger = currentElementsStorage.element( elementIndex );
					const subtracter = float( colorChanger ).div( gridWidth.mul( gridHeight ) );
					const color = vec3( subtracter.oneMinus() ).toVar();
					If( effectController.validate.equal( 1 ), () => {

						If( colorChanger.equal( elementIndex.add( 1 ) ), () => {

							color.g.assign( 255.0 );

						} ).Else( () => {

							color.r.assign( 255.0 );

						} );


					} );

					return color;

				} );

				material.colorNode = display();

				const plane = new THREE.Mesh( new THREE.PlaneGeometry( 1, 1 ), material );
				scene.add( plane );

				const renderer = new THREE.WebGPURenderer( { antialias: false, trackTimestamp: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth / 2, window.innerHeight );

				document.body.appendChild( renderer.domElement );
				renderer.domElement.style.position = 'absolute';
				renderer.domElement.style.top = '0';
				renderer.domElement.style.left = '0';
				renderer.domElement.style.width = '50%';
				renderer.domElement.style.height = '100%';

				if ( rightSide ) {

					renderer.domElement.style.left = '50%';

					scene.background = new THREE.Color( 0x212121 );
			
				} else {

					scene.background = new THREE.Color( 0x313131 );

				}

				let stepType = 'Init';

				 const stepAnimation = async function () {

					const algoType = rightSide ?
						effectController[ 'Right Display Algo' ] :
						effectController[ 'Left Display Algo' ];

					const algorithm = prefixSumMethods[ algoType ];

					switch ( stepType ) {

						case 'Run': {
			

							// Execute each dispatch
							for ( let i = 0; i < algorithm.threads.length; i ++ ) {

								renderer.compute( algorithm.runFunctions[ i ] );

							}

							stepType = 'Validate';

			
						}

							break;

						case 'Validate': {

							const currentElements = new Uint32Array( await renderer.getArrayBufferAsync( currentElementsBuffer ) );
							//console.log( currentElements );

							effectController.validate.value = 1;
							stepType = 'Init';

						}

							break;

						case 'Init': {

							renderer.compute( algorithm.initFunction );

							stepType = 'Run';

			
						}

							break;


					}

					renderer.render( scene, camera );

					effectController.validate.value = 0;

					setTimeout( stepAnimation, 1000 );
			
				};

				stepAnimation();

				window.addEventListener( 'resize', onWindowResize );

				function onWindowResize() {

					renderer.setSize( window.innerWidth / 2, window.innerHeight );

					const aspect = ( window.innerWidth / 2 ) / window.innerHeight;

					const frustumHeight = camera.top - camera.bottom;

					camera.left = - frustumHeight * aspect / 2;
					camera.right = frustumHeight * aspect / 2;

					camera.updateProjectionMatrix();

					renderer.render( scene, camera );

				}

			}
		</script>
	</body>
</html>