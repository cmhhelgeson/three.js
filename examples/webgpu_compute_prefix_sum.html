<html lang="en">
	<head>
		<title>three.js webgpu - storage pbo external element</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org" target="_blank" rel="noopener">three.js</a>
			<br /> Prefix sum performance comparisons.
			<br /> Each display loops through initialization, sum, and validation steps.
			<br/>
			<div id="local_swap" style="
				position: absolute;
				top: 150px;
				left: 0;
				padding: 10px;
				background: rgba( 0, 0, 0, 0.5 );
				color: #fff;
				font-family: monospace;
				font-size: 12px;
				line-height: 1.5;
				pointer-events: none;
				text-align: left;
			"></div>
			<div id="global_swap" style="
			position: absolute;
			top: 150px;
			right: 0;
			padding: 10px;
			background: rgba( 0, 0, 0, 0.5 );
			color: #fff;
			font-family: monospace;
			font-size: 12px;
			line-height: 1.5;
			pointer-events: none;
			text-align: left;
		"></div>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/tsl": "../build/three.webgpu.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three';
			import { If, vec3, Loop, uniform, uv, uint, float, Fn, vec2, uvec2, floor, pow, instanceIndex, invocationLocalIndex, workgroupBarrier, atomicAdd, atomicStore, workgroupId, storage } from 'three/tsl';

			import { GUI } from 'three/addons/libs/lil-gui.module.min.js';

			// Max number of elements that can be summed with a basic scan.
			// Corresponds to the default size of a workgroup in Three.js
			const maxScanElements = 16384;

			// Max number of elements in each display.
			const maxElements = 16384;

			const effectController = {
				// Sqr root of 16834
				leftGridDim: uniform( Math.sqrt( maxElements ) ),
				rightGridDim: uniform( Math.sqrt( maxScanElements ) ),
				validate: uniform( 0 ),
				// Algorithm being displayed
				'Left Method Name': 'Fake Prefix',
				'Right Method Name': 'Kogge-Stone (Dispatch)',
				// Category the algorithm belongs to.
				'Left Method Type': 'Validation',
				'Right Method Type': 'Scan',
			};

			const algorithms = [
				'Sklansky (Dispatch)',
				'Kogge-Stone (Dispatch)',
				'Fake Prefix',
				'Incorrect'
			];

			const gui = new GUI();

			const switchMethodType = ( side ) => {

				const methodType = `${side} Method Type`;

				switch ( effectController[ `${side} Display Algo` ] ) {

					case 'Fake Prefix':
					case 'Incorrect': {

						effectController[ methodType ] = 'Validation';
						break;

					}

					case 'Sklansky (Dispatch)':
					case 'Kogge-Stone (Dispatch)': {

						effectController[ methodType ] = 'Scan';

						break;
			
					}

			
				}



			
			};

			gui.add( effectController, 'Left Method Name', algorithms ).onChange( () => {

				switchMethodType( 'Left' );


			} );

			gui.add( effectController, 'Right Method Name', algorithms ).onChange( () => {
			
				switchMethodType( 'Right' );

			} );

			// Initialize Two Views
			init( false );
			init( true );

			// When forceGlobalSwap is true, force all valid local swaps to be global swaps.
			async function init( rightSide ) {

				// Create prefix sort data
				const array = new Uint32Array( Array.from( { length: maxElements }, ( _, i ) => {

					return i;

				} ) );

				const infoArray = new Uint32Array( 5 ).fill( 1 );

				const currentElementsBuffer = new THREE.StorageInstancedBufferAttribute( array, 1 );
				const currentElementsStorage = storage( currentElementsBuffer, 'uint', currentElementsBuffer.count ).label( 'Elements' );
				const infoBuffer = new THREE.StorageInstancedBufferAttribute( infoArray, 1 );
				const infoStorage = storage( infoBuffer, 'uint', infoBuffer.count );

				const initMethod = ( currentElements ) => {

					currentElements.element( instanceIndex ).assign( 1 );
			
				};


				const LoopThroughWorkgroup = ( callback ) => {

					const WORKGROUP_SIZE = uint( 64 ).toVar( 'WORKGROUP_SIZE' );

					Loop( {
						start: uint( 0 ),
						type: 'uint',
						end: uint( maxScanElements ),
						condition: '<',
						update: '+= WORKGROUP_SIZE',
						name: 'workgroupIndex'
					}, callback );

				};


				// Define and compile prefix sum methods.
				const prefixSumMethods = {
					// Methods to test whether the prefix sum validation is working as expected.
					'Validation': {
						// Emulates a prefix sum by manually assigning the instanceIndex to the storage buffer.
						// This method should only be used to validate the correctness of new algorithms, and not as
						// a yardstick for performance.
						'Fake Prefix': {
							threads: [ maxElements ],
							runMethod: ( currentElements ) => {

								currentElements.element( instanceIndex ).assign( instanceIndex.add( 1 ) );
			
							},
						},
						// Emulates an incorrect prefix sum by manually assigning the instanceIndex's inverse value.
						// Used to demonstrate a completely incorrect algorithm
						'Incorrect': {
							threads: [ maxElements ],
							runMethod: ( currentElements ) => {

								currentElements.element( instanceIndex ).assign( uint( maxElements ).sub( instanceIndex ) );

							},
						}
					},
					'Scan': {
						'Sklansky (Dispatch)': {
							threads: [ 64 ],
							runMethod: ( currentElements ) => {

								const WORKGROUP_SIZE = uint( 64 ).toVar( 'WORKGROUP_SIZE' );
								const prevReduction = uint( 0 ).toVar( 'prevReduction' );

								Loop( {
									start: uint( 0 ),
									type: 'uint',
									end: uint( Math.log2( WORKGROUP_SIZE ) - 1 ),
									condition: '<',
									update: '+= 1',
									name: 'iteration'
								}, ( { iteration } ) => {

									const step = pow( 2, iteration.add( 1 ) ).toVar( 'step' );

									// Alternative (Way I would like to use)

									const jStart = uint( pow( 2, iteration ).sub( 1 ) );
									const kIters = uint( pow( 2, iteration ) );

									const accessIndex = jStart.add( step.mul( invocationLocalIndex.div( kIters ) ) );
									const assignIndex = fract( invocationLocalIndex, kIters ).add( 1 );

									currentElements.element( assignIndex ).addAssign( currentElements.element( accessIndex ) );

									workgroupBarrier();

			

									// Pseudo code direct

									Loop( {
										start: uint( pow( 2, iteration ).sub( 1 ) ),
										type: 'uint',
										end: WORKGROUP_SIZE,
										condition: '<',
										update: '+= step',
										name: 'j',
									}, ( { j } ) => {

										Loop( {
											start: uint( 0 ),
											type: 'uint',
											end: uint( pow( 2, iteration ) ),
											condition: '<',
											update: '+= 1',
											name: 'k'
										}, ( { k } ) => {
			
											currentElements.element( j.add( k ).add( 1 ) ).addAssign( currentElements.element( j ) );

											workgroupBarrier();

										} );

									} );

								} );


							},
						},
						'Kogge-Stone (Dispatch)': {
							threads: [ 64 ],
							initMethod: ( currentElements, info ) => {

								initMethod( currentElements );
								info.element( 0 ).assign( 1 );

							},
							runMethod: ( currentElements ) => {

								const WORKGROUP_SIZE = uint( 64 ).toVar( 'WORKGROUP_SIZE' );
								const prevReduction = uint( 0 ).toVar( 'prevReduction' );

								LoopThroughWorkgroup( ( { workgroupIndex } ) => {

									Loop( {
										start: uint( 1 ),
										end: WORKGROUP_SIZE,
										type: 'uint',
										condition: '<=',
										update: '<<= 1',
										name: 'j',
									}, ( { j } ) => {

										const t = uint( 0 ).toVar( 't' );

										If( invocationLocalIndex.greaterThanEqual( j ), () => {

											t.assign( currentElements.element( invocationLocalIndex.sub( j ).add( workgroupIndex ) ) );


										} );
			
										workgroupBarrier();

										If( invocationLocalIndex.greaterThanEqual( j ), () => {

											currentElements.element( invocationLocalIndex.add( workgroupIndex ) ).addAssign( t );

										} );

										workgroupBarrier();


									} );

									currentElements.element( invocationLocalIndex.add( workgroupIndex ) ).addAssign( prevReduction );
									workgroupBarrier();

									prevReduction.assign( currentElements.element( workgroupIndex.add( WORKGROUP_SIZE ).sub( 1 ) ) );

								} );

							}
						}
					}
				};

				console.log( prefixSumMethods );

				// Pre-compile shaders
				for ( const methodType in prefixSumMethods ) {

					console.log( methodType );

					let numElements = 0;
					switch ( methodType ) {

						case 'Validation': {

							numElements = maxElements;
							break;

						}

						case 'Scan': {

							numElements = maxScanElements;
							break;
			
						}


					}

					for ( const methodName in prefixSumMethods[ methodType ] ) {

						console.log( methodName );

						const method = prefixSumMethods[ methodType ][ methodName ];

						// Compile init function
						if ( method.initMethod ) {

							method.initFunction = Fn( () => {

								method.initMethod( currentElementsStorage, infoStorage );

							} )().compute( numElements );

						} else {

							method.initFunction = Fn( () => {

								initMethod( currentElementsStorage );

							} )().compute( numElements );

						}

						method.runFunctions = [];

						const runFunctionTemplate = Fn( ( ) => {

							method.runMethod( currentElementsStorage, infoStorage );

						} );

						for ( let i = 0; i < method.threads.length; i ++ ) {

							method.runFunctions.push( runFunctionTemplate().compute( method.threads[ i ] ) );

						}
			
					}

				}
			
				console.log( prefixSumMethods );

				// Create standard scene
				const aspect = ( window.innerWidth / 2 ) / window.innerHeight;
				const camera = new THREE.OrthographicCamera( - aspect, aspect, 1, - 1, 0, 2 );
				camera.position.z = 1;

				const scene = new THREE.Scene();

				const material = new THREE.MeshBasicNodeMaterial( { color: 0x00ff00 } );

				const display = Fn( () => {

					const gridDim = rightSide ? effectController.rightGridDim : effectController.leftGridDim;
					const newUV = uv().mul( vec2( gridDim ) );
					const pixel = uvec2( uint( floor( newUV.x ) ), uint( floor( newUV.y ) ) );
					const elementIndex = uint( gridDim ).mul( pixel.y ).add( pixel.x );
					const colorChanger = currentElementsStorage.element( elementIndex );
					const subtracter = float( colorChanger ).div( gridDim.mul( gridDim ) );
					const color = vec3( subtracter.oneMinus() ).toVar();
					If( effectController.validate.equal( 1 ), () => {

						If( colorChanger.equal( elementIndex.add( 1 ) ), () => {

							color.g.assign( 255.0 );

						} ).Else( () => {

							color.r.assign( 255.0 );

						} );


					} );

					return color;

				} );

				material.colorNode = display();

				const plane = new THREE.Mesh( new THREE.PlaneGeometry( 1, 1 ), material );
				scene.add( plane );

				const renderer = new THREE.WebGPURenderer( { antialias: false, trackTimestamp: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth / 2, window.innerHeight );

				document.body.appendChild( renderer.domElement );
				renderer.domElement.style.position = 'absolute';
				renderer.domElement.style.top = '0';
				renderer.domElement.style.left = '0';
				renderer.domElement.style.width = '50%';
				renderer.domElement.style.height = '100%';

				if ( rightSide ) {

					renderer.domElement.style.left = '50%';

					scene.background = new THREE.Color( 0x212121 );
			
				} else {

					scene.background = new THREE.Color( 0x313131 );

				}

				let stepType = 'Init';

				 const stepAnimation = async function () {

					const methodType = rightSide ?
						effectController[ 'Right Method Type' ] :
						effectController[ 'Left Method Type' ];

					const methodName = rightSide ?
						effectController[ 'Right Method Name' ] :
						effectController[ 'Left Method Name' ];

					const method = prefixSumMethods[ methodType ][ methodName ];

					switch ( stepType ) {

						case 'Run': {
			

							// Execute each dispatch
							for ( let i = 0; i < method.threads.length; i ++ ) {

								renderer.compute( method.runFunctions[ i ] );

							}

							stepType = 'Validate';

			
						}

							break;

						case 'Validate': {

							const currentElements = new Uint32Array( await renderer.getArrayBufferAsync( currentElementsBuffer ) );
							//console.log( currentElements );

							effectController.validate.value = 1;
							stepType = 'Init';

						}

							break;

						case 'Init': {

							console.log( `${methodType} ${methodName}` );
							console.log( method.initFunction );

							renderer.compute( method.initFunction );

							stepType = 'Run';

			
						}

							break;


					}

					renderer.render( scene, camera );

					effectController.validate.value = 0;

					setTimeout( stepAnimation, 1000 );
			
				};

				stepAnimation();

				window.addEventListener( 'resize', onWindowResize );

				function onWindowResize() {

					renderer.setSize( window.innerWidth / 2, window.innerHeight );

					const aspect = ( window.innerWidth / 2 ) / window.innerHeight;

					const frustumHeight = camera.top - camera.bottom;

					camera.left = - frustumHeight * aspect / 2;
					camera.right = frustumHeight * aspect / 2;

					camera.updateProjectionMatrix();

					renderer.render( scene, camera );

				}

			}
		</script>
	</body>
</html>