<html lang="en">
	<head>
		<title>three.js webgpu - storage pbo external element</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org" target="_blank" rel="noopener">three.js</a>
			<br /> This example demonstrates a bitonic sort running step by step in a compute shader.
			<br /> The left canvas swaps values within workgroup local arrays. The right swaps values within storage buffers.
			<br /> Reference implementation by <a href="https://poniesandlight.co.uk/reflect/bitonic_merge_sort/">Tim Gfrerer</a>
			<br /> 
			<div id="local_swap" style="
				position: absolute;
				top: 150px;
				left: 0;
				padding: 10px;
				background: rgba( 0, 0, 0, 0.5 );
				color: #fff;
				font-family: monospace;
				font-size: 12px;
				line-height: 1.5;
				pointer-events: none;
				text-align: left;
			"></div>
			<div id="global_swap" style="
			position: absolute;
			top: 150px;
			right: 0;
			padding: 10px;
			background: rgba( 0, 0, 0, 0.5 );
			color: #fff;
			font-family: monospace;
			font-size: 12px;
			line-height: 1.5;
			pointer-events: none;
			text-align: left;
		"></div>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/tsl": "../build/three.webgpu.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three';
			import { storageObject, If, vec3, uniform, uv, uint, float, Fn, vec2, uvec2, floor, instanceIndex, workgroupBarrier, atomicAdd, atomicStore, workgroupId, storage } from 'three/tsl';

			import { GUI } from 'three/addons/libs/lil-gui.module.min.js';

			const numElements = 16384;


			const computePrefixSklanskyFn = Fn( ( currentElements, uniformStorage ) => {

				If( instanceIndex.equal( numElements - 1 ), () => {

					uniformStorage.element( 0 ).mulAssign( 2 );

				} );


			} )().compute();

			const computePrefixKoggeStoneFn = Fn( () => {

			


			} )().compute();

			const prefixSumMethods = {
				// Emulates a prefix sum by manually assigning the instanceIndex to the storage buffer
				'Reset': {
					threads: [ numElements ],
					dispatches: 1,
					initFn: Fn( ( [ currentElements ] ) => {

						currentElements.element( instanceIndex ).equal( 8000 );
			
					} ),
					runFn: Fn( ( [ currentElements ] ) => {

						currentElements.element( instanceIndex ).equal( instanceIndex );


					} )
				},
				// Incorrect prefix sum to test the validation
				'Incorrect': {
					threads: [ numElements ],
					dispatches: 1,
					initFn: Fn( ( [ currentElements ] ) => {
			
						currentElements.element( instanceIndex ).equal( 7 );


					} ),
					runFn: Fn( ( [ currentElements ] ) => {

						currentElements.element( instanceIndex ).equal( uint( numElements ).sub( instanceIndex ) );

					} )
				},
				'Sklansky (Favor Dispatch)': {
					threads: Array( Math.log2( numElements ) ).fill( numElements / 2 ),
					initFn: () => console.log( 'test' ),
					runFn: computePrefixSklanskyFn,
					dispatches: Math.log2( numElements ),
				},
				'Kogge-Stone (Favor Dispatch)': {
					threads: Array( Math.log2( numElements ) ).map( ( _, idx ) => {

						return numElements - 2 ** idx;
			
					} ),
					initFn: () => console.log( 'test' ),
					runFn: computePrefixKoggeStoneFn,
					dispatches: Math.log2( numElements )
				}
			};


			const effectController = {
				// Sqr root of 16834
				gridWidth: uniform( Math.sqrt( numElements ) ),
				gridHeight: uniform( Math.sqrt( numElements ) ),
				highlight: uniform( 1 ),
				'Display Mode': 'Swap Zone Highlight'
			};

			const gui = new GUI();
			gui.add( effectController, 'Display Mode', [ 'Elements', 'Swap Zone Highlight' ] ).onChange( () => {

				if ( effectController[ 'Display Mode' ] === 'Elements' ) {

					effectController.highlight.value = 0;

			
				} else {

					effectController.highlight.value = 1;
			
				}

			
			} );

			// Allow Workgroup Array Swaps
			init( false, 'Reset' );

			// Global Swaps Only
			init( true, 'Incorrect' );


			// When forceGlobalSwap is true, force all valid local swaps to be global swaps.
			async function init( forceGlobalSwap, algoType ) {

				const aspect = ( window.innerWidth / 2 ) / window.innerHeight;
				const camera = new THREE.OrthographicCamera( - aspect, aspect, 1, - 1, 0, 2 );
				camera.position.z = 1;

				const scene = new THREE.Scene();

				const array = new Uint32Array( Array.from( { length: numElements }, ( _, i ) => {

					return i;

				} ) );


				const currentElementsBuffer = new THREE.StorageInstancedBufferAttribute( array, 1 );
				const currentElementsStorage = storage( currentElementsBuffer, 'uint', numElements ).label( 'Elements' );

				const material = new THREE.MeshBasicNodeMaterial( { color: 0x00ff00 } );

				const display = Fn( () => {

					const { gridWidth, gridHeight } = effectController;

					const newUV = uv().mul( vec2( gridWidth, gridHeight ) );

					const pixel = uvec2( uint( floor( newUV.x ) ), uint( floor( newUV.y ) ) );

					const elementIndex = uint( gridWidth ).mul( pixel.y ).add( pixel.x );

					const colorChanger = currentElementsStorage.element( elementIndex );

					const subtracter = float( colorChanger ).div( gridWidth.mul( gridHeight ) );

					const color = vec3( subtracter.oneMinus() ).toVar();

					return color;

				} );

				material.colorNode = display();

				const plane = new THREE.Mesh( new THREE.PlaneGeometry( 1, 1 ), material );
				scene.add( plane );

				const renderer = new THREE.WebGPURenderer( { antialias: false, trackTimestamp: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth / 2, window.innerHeight );

				//renderer.setAnimationLoop( animate );

				document.body.appendChild( renderer.domElement );
				renderer.domElement.style.position = 'absolute';
				renderer.domElement.style.top = '0';
				renderer.domElement.style.left = '0';
				renderer.domElement.style.width = '50%';
				renderer.domElement.style.height = '100%';

				if ( forceGlobalSwap ) {

					renderer.domElement.style.left = '50%';

					scene.background = new THREE.Color( 0x212121 );
			
				} else {

					scene.background = new THREE.Color( 0x313131 );

				}

				const algorithm = prefixSumMethods[ algoType ];
			
				const init = algorithm.initFn( currentElementsStorage ).compute( numElements );

				renderer.compute( init );

				let isRun = true;

				 const stepAnimation = async function () {

					if ( isRun ) {

						console.log( `Running prefix sum algo: ${algoType}` );

						for ( let i = 0; i < algorithm.dispatches; i ++ ) {

							console.log( algorithm );

							const compiled = algorithm.runFn( currentElementsStorage ).compute( algorithm.threads[ i ] );

							renderer.compute( compiled );

						}

						isRun = false;

					} else {

						console.log( `Initializing prefix sum algo: ${algoType}` );
						renderer.compute( algorithm.initFn( currentElementsStorage ).compute( numElements ) );

						isRun = true;


					}

					renderer.render( scene, camera );

					setTimeout( stepAnimation, 1000 );
			

				};

				stepAnimation();

				window.addEventListener( 'resize', onWindowResize );

				function onWindowResize() {

					renderer.setSize( window.innerWidth / 2, window.innerHeight );

					const aspect = ( window.innerWidth / 2 ) / window.innerHeight;

					const frustumHeight = camera.top - camera.bottom;

					camera.left = - frustumHeight * aspect / 2;
					camera.right = frustumHeight * aspect / 2;

					camera.updateProjectionMatrix();

					renderer.render( scene, camera );

				}

			}
		</script>
	</body>
</html>