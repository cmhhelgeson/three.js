<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgpu - compute - protoplanet</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> - <span id="protoplanets"></span> webgpu compute debris
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/tsl": "../build/three.webgpu.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three';
			import { storage, storageObject, Discard, smoothstep, property, vec2, Continue, length, Fn, instanceIndex, vec4, If, float, attribute, vec3, timerDelta, pow, Loop, uint, Break, min, normalize, uniform, modelViewMatrix, varying, } from 'three/tsl';

			import Stats from 'three/addons/libs/stats.module.js';
			import { GUI } from 'three/addons/libs/lil-gui.module.min.js';

			import InstancedPoints from 'three/addons/objects/InstancedPoints.js';
			import InstancedPointsGeometry from 'three/addons/geometries/InstancedPointsGeometry.js';

			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

			let container, stats;
			let camera, scene, renderer, geometry;

			let computePosition, computeVelocity;

			const PARTICLES = 4096;
			const PARTICLES_SQRT = Math.sqrt( 4096 );

			let effectController;

			init();

			function init() {

				// Initialize scene
			
				container = document.createElement( 'div' );
				document.body.appendChild( container );

				camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 5, 15000 );
				camera.position.y = 120;
				camera.position.z = 400;

				scene = new THREE.Scene();

				renderer = new THREE.WebGPURenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( animate );
				container.appendChild( renderer.domElement );

				const controls = new OrbitControls( camera, renderer.domElement );
				controls.minDistance = 100;
				controls.maxDistance = 1000;

				effectController = {
					// Uniforms
					gravity: uniform( 100.0 ).label( 'gravity' ),
					density: uniform( 0.45 ).label( 'density' ),
					cameraConstant: uniform( getCameraConstant( camera ) ).label( 'cameraConstant' ),

					// Must restart simulation
					radius: 300,
					height: 8,
					exponent: 0.4,
					maxMass: 15.0,
					velocity: 70,
					velocityExponent: 0.2,
					randVelocity: 0.001
				};

				// Create initial Proto-Planet Position and Velocity Buffers

				const posArray = new Float32Array( PARTICLES * 3 );
				const velArray = new Float32Array( PARTICLES * 3 );
				const massArray = new Float32Array( PARTICLES );
				const sizeArray = new Float32Array( PARTICLES );

				const radiusFromMass = ( mass ) => {

					return Math.pow( ( 3.0 / ( 4.0 * Math.PI ) ) * mass / effectController.density.value, 1.0 / 3.0 );

				};

				// TODO: Parallelize
				const fillBuffers = () => {

					const radius = effectController.radius;
					const height = effectController.height;
					const exponent = effectController.exponent;
					const maxMass = effectController.maxMass * 1024 / PARTICLES;
					const maxVel = effectController.velocity;
					const velExponent = effectController.velocityExponent;
					const randVel = effectController.randVelocity;

					for ( let k = 0, kl = posArray.length; k < kl; k += 3 ) {

						// Position
						let x, z, rr;

						do {

							x = ( Math.random() * 2 - 1 );
							z = ( Math.random() * 2 - 1 );
							rr = x * x + z * z;

						} while ( rr > 1 );

						rr = Math.sqrt( rr );

						const rExp = radius * Math.pow( rr, exponent );

						// Velocity
						const vel = maxVel * Math.pow( rr, velExponent );

						const vx = vel * z + ( Math.random() * 2 - 1 ) * randVel;
						const vy = ( Math.random() * 2 - 1 ) * randVel * 0.05;
						const vz = - vel * x + ( Math.random() * 2 - 1 ) * randVel;

						x *= rExp;
						z *= rExp;
						const y = ( Math.random() * 2 - 1 ) * height;

						const mass = Math.random() * maxMass + 1;

						// Fill in texture values
						posArray[ k + 0 ] = x;
						posArray[ k + 1 ] = y;
						posArray[ k + 2 ] = z;

						velArray[ k + 0 ] = vx;
						velArray[ k + 1 ] = vy;
						velArray[ k + 2 ] = vz;

						massArray[ k ] = mass;

					}

				};

				fillBuffers();

				// Initialize Proto Planet Geometry and Material

				geometry = new InstancedPointsGeometry();
				geometry.setPositions( posArray );

				// Instance Position
				const positionAttribute = new THREE.StorageInstancedBufferAttribute( posArray, 3 );
				geometry.setAttribute( 'instancePosition', positionAttribute );
				const posStorage = storage( positionAttribute, 'vec3', positionAttribute.count ).label( 'Pos' );

				// Instance Velocity
				const velocityBufferAttribute = new THREE.StorageBufferAttribute( velArray, 3 );
				geometry.setAttribute( 'instanceVelocity', velocityBufferAttribute );
				const velocityStorage = storage( velocityBufferAttribute, 'vec3', velocityBufferAttribute.count ).label( 'Velocity' );

				// Instance Size
				const sizeBufferAttribute = new THREE.StorageBufferAttribute( sizeArray, 1 );
				geometry.setAttribute( 'instanceSize', sizeBufferAttribute );
				const sizeStorage = storage( sizeBufferAttribute, 'float', sizeBufferAttribute.count ).label( 'Size' );

				// Mass ( does not get passed in as attribute )
				const massBufferAttribute = new THREE.StorageBufferAttribute( massArray, 1 );
				const massStorage = storage( massBufferAttribute, 'float', massBufferAttribute.count ).label( 'Mass' );
				const massRead = storageObject( massBufferAttribute, 'float', massBufferAttribute.count ).label( 'MassRead' );

				geometry.instanceCount = posArray.length / 3; // this should not be necessary

				// Write proto planet velocity and position compute shaders

				const radiusFromMassTSL = ( mass ) => {

					const { density } = effectController;

					const massOverDensity = mass.div( density );
					const piCalc = float( 3.0 ).div( 4.0 * Math.PI );
					return pow( piCalc.mul( massOverDensity ), 1 / 3 );

				};

				computeVelocity = Fn( () => {

					const { gravity } = effectController;
					const pos = posStorage.element( instanceIndex );
					const vel = velocityStorage.element( instanceIndex ).toVar();
					vel.name = 'vel';
					const mass = massStorage.element( instanceIndex ).toVar();
					mass.name = 'mass';

					If( mass.greaterThan( 0.0 ), () => {

						/* When Three.js translates TSL to WGSL or GLSL code, it will often translate your code
						/* from variables to references to mathematical calculations. For instance:
			
						/*      TSL Input:
			
						/*          const radius = float(1.0).add( 1.0 ) ;
						/*          return float(2.0).add(radius);
			
						/*      WGSL Output:
			
						/*          return 2.0 + 1.0 + 1.0;
			
						/* In cases where you explicitly need to access a value as a variable, apply .toVar() to node.
			
						/*      TSL Input:

						/*           const radius = float( 1.0 ).add( 1.0 );
						/*           return float(3.0).add(radius)
			
						/*      WGSL Output:
						/*
						/*           let radius = 1.0 + 1.0;
						/*           return 3.0 + radius;
						*/

						const radius = radiusFromMassTSL( mass ).toVar();

						const acceleration = vec3( 0.0 ).toVar();

						Loop( { start: uint( 0 ), end: uint( PARTICLES_SQRT ), type: 'uint', condition: '<' }, ( { i } ) => {

							Loop( { start: uint( 0 ), end: uint( PARTICLES_SQRT ), type: 'uint', condition: '<' }, ( { i } ) => {

								// Reject comparison between two particles under certain conditions.

								If( instanceIndex.equal( i ), () => {

									Continue();

								} );

								const mass2 = massStorage.element( i ).toVar();
								mass2.name = 'mass2';

								If( mass2.equal( 0.0 ), () => {

									Continue();

								} );

								// Use toVar() to prevent repeat of calculation
								const pos2 = posStorage.element( i );
								const posDelta = pos2.sub( pos );
								const distance = length( posDelta ).toVar();

								If( distance.equal( 0.0 ), () => {

									Continue();

								} );


								const vel2 = velocityStorage.element( i );
								const radius2 = radiusFromMassTSL( mass2 );

								// Checks collision

								If( distance.lessThan( radius.add( radius2 ) ), () => {

									If( instanceIndex.lessThan( i ), () => {

										// This particle is aggregated by the other
										const velByMass = vel.mul( mass );
										const vel2ByMass = vel2.mul( mass2 );
										const newVel = ( velByMass.add( vel2ByMass ) ).div( mass.add( mass2 ) );
			
										// Update velocity, mass, and radius
										vel.assign( newVel );
										mass.addAssign( mass2 );
										radius.assign( radiusFromMassTSL( mass ) );

									} ).Else( () => {

										/* .toVar() call prevents radius calculation from being translated incorrectly.
									/* Without .toVar():
									/*      pow_float( mass / uniform * 0.238 ) = 0.0;
									/* With .toVar():
									/*      nodeVar0 = pow_float( mass / uniform * 0.238 );
									/*      nodeVar0 = 0.0;
									*/

										// This particle dies
										mass.assign( 0.0 );
										radius.assign( 0.0 );
										vel.assign( vec3( 0.0 ) );

										Break();

									} );

								} );

								const distanceSq = distance.mul( distance ).toVar();
								distanceSq.name = 'distanceSq';

								const gravityField = min( gravity.mul( mass2 ).div( distanceSq ), 1000.0 ).toVar();
								gravityField.name = 'gravityField';

								acceleration.addAssign( gravityField.mul( normalize( posDelta ) ) );

							} );

							// TODO: Investigate difference between single loop and double loop behavior
							If( mass.equal( 0.0 ), () => {

								Break();

							} );


						} );

						velocityStorage.element( instanceIndex ).addAssign( acceleration.mul( timerDelta() ) );
						massStorage.element( instanceIndex ).assign( mass );

					} );

				} )().compute( PARTICLES );

				computePosition = Fn( () => {

					const { cameraConstant } = effectController;

					const position = posStorage.element( instanceIndex );
					const velocity = velocityStorage.element( instanceIndex ).toVar();
					const size = sizeStorage.element( instanceIndex );
					const mass = massStorage.element( instanceIndex );

					const radius = radiusFromMassTSL( mass );

					If( mass.equal( 0.0 ), () => {

						velocity.assign( vec3( 0.0 ) );
						size.assign( 0.0 );

					} ).Else( () => {

						size.assign( radius.mul( cameraConstant ) );
			
					} );

					position.addAssign( velocity.mul( timerDelta() ) );

				} )().compute( PARTICLES );

				// THREE.ShaderMaterial
				const planetMaterial = new THREE.InstancedPointsNodeMaterial( {
			
					color: 0xffffff,
					alphaToCoverage: true,
			
				} );
			
				const mvPosition = modelViewMatrix.mul( attribute( 'instancePosition' ) );
				planetMaterial.pointSizeNode = float( 10.0 );//attribute( 'instanceSize' ).div( negate( mvPosition.z ) );
				// Override InstancedPointsNodeMaterial fragment shader.
				planetMaterial.fragmentNode = Fn( () => {

					const vUv = varying( vec2(), 'vUv' );

					// force assignment into correct place in flow
					const alpha = property( 'float', 'alpha' );
					alpha.assign( 1 );

					const a = vUv.x;
					const b = vUv.y;

					const len2 = a.mul( a ).add( b.mul( b ) );

					// force assignment out of following 'if' statement - to avoid uniform control flow errors
					const dlen = property( 'float', 'dlen' );
					dlen.assign( len2.fwidth() );
					alpha.assign( smoothstep( dlen.oneMinus(), dlen.add( 1 ), len2 ).oneMinus() );

					const y = massRead.element( instanceIndex ).div( 250.0 );

					If( y.equal( 0.0 ), () => {

						Discard();

					} );

					return vec4( 1.0, y, 0.0, alpha );
			
				} )();
			
				// No need to set positionNode as position is already handled internally.

				const particles = new InstancedPoints( geometry, planetMaterial );
				particles.scale.set( 1, 1, 1 );
				scene.add( particles );

				stats = new Stats();
				container.appendChild( stats.dom );

				window.addEventListener( 'resize', onWindowResize );

				// Init Gui

				const gui = new GUI( { width: 280 } );

				const folder1 = gui.addFolder( 'Dynamic parameters' );
				folder1.add( effectController.gravity, 'value', 0.0, 1000.0, 0.05 ).name( 'gravity' );
				folder1.add( effectController.density, 'value', 0.0, 10.0, 0.001 ).name( 'density' );

				const folder2 = gui.addFolder( 'Static parameters' );
				folder2.add( effectController, 'radius', 10.0, 1000.0, 1.0 );
				folder2.add( effectController, 'height', 0.0, 50.0, 0.01 );
				folder2.add( effectController, 'exponent', 0.0, 2.0, 0.001 );
				folder2.add( effectController, 'maxMass', 1.0, 50.0, 0.1 );
				folder2.add( effectController, 'velocity', 0.0, 150.0, 0.1 );
				folder2.add( effectController, 'velocityExponent', 0.0, 1.0, 0.01 );
				folder2.add( effectController, 'randVelocity', 0.0, 50.0, 0.1 );

				const buttonRestart = {
					restartSimulation: function () {

						fillBuffers();

					}
				};

				folder2.add( buttonRestart, 'restartSimulation' );

				folder1.open();
				folder2.open();

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

				effectController.cameraConstant.value = getCameraConstant( camera );
				console.log( effectController.cameraConstant.value );

			}

			function getCameraConstant( camera ) {

				return window.innerHeight / ( Math.tan( THREE.MathUtils.DEG2RAD * 0.5 * camera.fov ) / camera.zoom );

			}

			function animate() {

				render();
				stats.update();

			}

			function render() {

				renderer.compute( computeVelocity );
				renderer.compute( computePosition );

				renderer.render( scene, camera );

			}

		</script>
	</body>
</html>
