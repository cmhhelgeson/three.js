<html lang="en">
	<head>
		<title>three.js - WebGPU - Fluid Tunnel</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> WebGPU - Fluid Tunnel
		</div>
		<div id="container">
			<canvas id="c"></canvas>
		
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.module.js",
					"three/addons/": "./jsm/",
					"three/nodes": "./jsm/nodes/Nodes.js"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three';
			import { vec2, vec3, vec4, floor, uv, remainder, If, tslFn, storageTexture, expression, MeshBasicNodeMaterial, temp, negate, storage, storageReadOnly, wgslFn, code, instanceIndex, uniform, Return } from 'three/nodes';

			import WebGPU from 'three/addons/capabilities/WebGPU.js';
			import WebGPURenderer from 'three/addons/renderers/webgpu/WebGPURenderer.js';
			import StorageTexture from 'three/addons/renderers/common/StorageTexture.js';
			import StorageBufferAttribute from 'three/addons/renderers/common/StorageBufferAttribute.js';

			import { GUI } from 'three/addons/libs/lil-gui.module.min.js';

			let camera, scene, renderer;
			let computeInitNode, computeToPing, computeToPong;
			let pingTexture, pongTexture;
			let material;
			let phase = true;
			let lastUpdate = - 1;
			let storageFragmentShader, textureFragmentShader;
			// Step 1. Apply gravity to velocity x, y (u, v);
			let computeIntegration;
			// Step 2. Compute divergence, make velocity of each cell incomrpessible
			let computeDiv_I0J0, computeDiv_I0J1, computeDiv_I1J0, computeDiv_I1J1;
			// Step 3. Extrapolate velocities of buffer cells from divergence velocities.
			let computeExtrapolateX, computeExtrapolateY;
			// Step 4. Advection
			let computeAdvection;

			const computeMethods = {
				'Storage Texture': 'storageTexture',
				'Storage Buffer': 'storageBuffer',
			}

			const canvas = document.getElementById('c');

			init();

			function init() {

				if ( WebGPU.isAvailable() === false ) {

					document.body.appendChild( WebGPU.getErrorMessage() );

					throw new Error( 'No WebGPU support' );

				}

				// Create renderer
				renderer = new WebGPURenderer( { antialias: true, canvas: canvas} );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( animate );
				document.body.appendChild( renderer.domElement );
				window.addEventListener( 'resize', onWindowResize );

				// Get domain information (making everything 1 to 1 for simplicity)
				const simHeight = 1.0;
				const cScale = canvas.height / simHeight;
				const simWidth = canvas.width / cScale;
				const res = 100;
				const domainHeight = 1.0;
				const domainWidth = domainHeight / simHeight * simWidth;
				const h = domainHeight / res;

				const simCols = Math.floor(domainWidth / h);
				const simRows = Math.floor(domainHeight / h);
				console.log(`simCols: ${simCols}, simRows: ${simRows}`);
				const numSimCells = simCols * simRows;

				const bufferCols = simCols + 2;
				const bufferRows = simRows + 2;
				console.log(`bufferCols: ${bufferCols}, bufferRows: ${bufferRows}`);
				const numBufferCells = bufferCols * bufferRows;

				// Velocity x (or u) located at center of left side of grid cell
				const velXStartBufferAttribute = new StorageBufferAttribute( numBufferCells, 1 );
				const velXDivergenceBufferAttribute = new StorageBufferAttribute( numBufferCells, 1 );
				const velXAdvectionBufferAttribute = new StorageBufferAttribute( numBufferCells, 1 );
				// Velocity y (or v) located at center of bottom side of grid cell
				const velYStartBufferAttribute = new StorageBufferAttribute( numBufferCells, 1 );
				const velYDivergenceBufferAttribute = new StorageBufferAttribute( numBufferCells, 1 );
				const velYAdvectionBufferAttribute = new StorageBufferAttribute( numBufferCells, 1 );

				const pressureBufferAttribute = new StorageBufferAttribute( numBufferCells, 1 );
				const dBufferAttribute = new StorageBufferAttribute( numBufferCells, 1 );
				const scalarBufferAttribute = new StorageBufferAttribute( numBufferCells, 1 );

				const overRelaxationUniform = uniform(1.9);
				const cpUniform = uniform(1000)
				const densityUniform = uniform(1000);

				const deltaTimeUniform = uniform( 1 / 120.0 );
				const gravityUniform = uniform( -9.81 );

				const createReadStorage = ( attribute, type ) => storageReadOnly( attribute, type, numBufferCells);
				// Technically read-write storage
				const createWriteStorage = ( attribute, type ) => storage( attribute, type, numBufferCells );

				const getCellIndexFromInstanceIndex = () => {

					// 2D index of sim grid cell (x, y)
					const simGridCol = temp(instanceIndex.remainder(simCols), 'simGridX');
					const simGridRow = temp(instanceIndex.div(simCols), 'simGridY');
					// 2D index of sim grid cell in buffered grid (x, y)
					const bufferGridCol = temp(simGridCol.add(1), 'bufferGridX');
					const bufferGridRow = temp(simGridRow.add(1), 'bufferGridY');

					// Convert to 1D index into buffered grid for storage buffer access
					return temp(bufferGridCol.add(bufferGridRow.mul(bufferCols)), 'cellIndex');

				}

				const getOffsetCellIndex = (dispatchesX, offsetX, offsetY) => {

					// Work in the coordinates of our non-adjacent cells compressed together into a separate grid
					// In a 2d compute execution context, these are analagous with the x and y ids of our threads
					const compactGridCol = temp(instanceIndex.remainder(dispatchesX), 'compactGridX');
					const compactGridRow = temp(instanceIndex.div(dispatchesX), 'compactGridY' );

					// Get location of compact grid cell in sim grid cell space
					const simGridCol = compactGridCol.mul(2).add(offsetX);
					const simGridRow = compactGridRow.mul(2).add(offsetY);

					// Get index of sim grid cell in buffer grid (x, y)
					const bufferGridCol = temp(simGridCol.add(1), 'bufferGridX');
					const bufferGridRow = temp(simGridRow.add(1), 'bufferGridY');

					// Convert to 1D index into buffered grid for storage buffer access
					return temp(
						bufferGridCol.add(bufferGridRow.mul(bufferCols)),
						'cellIndex',
					);

				}

				const calculateDivergenceStepDispatches = (numCols, numRows, offsetX, offsetY) => {
					const dispatchX = Math.floor( (numCols + 1 - offsetX) / 2);
					const dispatchY = Math.floor( (numRows + 1 - offsetY) / 2);
					return { dispatchX, dispatchY };
				}

				const testDivergenceSteps = (numCols, numRows) => {
					console.log(calculateDivergenceStepDispatches(numCols, numRows, 0, 0));
					console.log(calculateDivergenceStepDispatches(numCols, numRows, 1, 0))
					console.log(calculateDivergenceStepDispatches(numCols, numRows, 0, 1))
					console.log(calculateDivergenceStepDispatches(numCols, numRows, 1, 1))
				}

				testDivergenceSteps(6, 6);

				const createDivergenceShader = (offsetX, offsetY) => {

					const {dispatchX, dispatchY} = calculateDivergenceStepDispatches(simCols, simRows, offsetX, offsetY);
					const dispatches = dispatchX * dispatchY;

					return tslFn(() => {
					// Create shader storage buffers
						const velXRead = createReadStorage( velXStartBufferAttribute, 'float');
						const velYRead = createReadStorage( velXStartBufferAttribute, 'float');

						const velXWrite = createWriteStorage( velXDivergenceBufferAttribute, 'float');
						const velYWrite = createWriteStorage( velYDivergenceBufferAttribute, 'float');

						const pressureWrite = createWriteStorage( pressureBufferAttribute, 'float');
						const scalarRead = createReadStorage( scalarBufferAttribute, 'uint');

						const cellIndex = getOffsetCellIndex(dispatchX, offsetX, offsetY);
					
						// No need for boundary checks since our cellIndex is buffered
						const lIndex = temp(cellIndex.sub(1), 'cellLeftIndex');
						const rIndex = temp(cellIndex.add(1), 'cellRightIndex');
						const uIndex = temp(cellIndex.add(bufferCols), 'cellAboveIndex');
						const bIndex = temp(cellIndex.sub(bufferCols), 'cellBelowIndex');

						const [lScalar, rScalar, uScalar, bScalar] = getIndexedValuesFromStorage(scalarRead, [lIndex, rIndex, uIndex, bIndex]);

						const cellScalar = temp(lScalar.add(rScalar).add(uScalar).add(bScalar), 'cellScalar');

						If(cellScalar.equal(0.0), () => {
							Return();
						});

						// Subtract inflow of current cell from inflow of adjacent cells to get the outflow.
						// Current cell inflow represents negative outflow from current cell.
						const currentCellInflowX = temp(velXRead.element(cellIndex), 'currentCellInflowX');
						const currentCellInflowY = temp(velYRead.element(cellIndex), 'currentCellInflowY');
						const currentCellInflow = temp(currentCellInflowX.add(currentCellInflowY), 'currentCellInflow');

						// Adjacent cell inflow represents positive outflow from current cell.
						const adjacentCellInflowX = velXRead.element(rIndex);
						const adjacentCellInflowY = velYRead.element(uIndex);
						const adjacentCellInflow = temp(adjacentCellInflowX.add(adjacentCellInflowY), 'adjacentCellInfow');

						const outflow = temp(adjacentCellInflow.sub(currentCellInflow), 'outflow');
						const negativeOutflow = outflow.sub(outflow.mul(2))
					
						let pressure = negativeOutflow.div(cellScalar);
						pressure.mulAssign(overRelaxationUniform);
					
						pressureWrite.element(cellIndex).addAssign(pressure);

						// Apply scalars to cell velocities
						// Velocity X
						velXWrite.element(cellIndex).subAssign(lScalar.mul(pressure));
						velXWrite.element(rIndex).addAssign(rScalar.mul(pressure));
						// Velocity Y
						velYWrite.element(cellIndex).subAssign(bScalar.mul(pressure));
						velXWrite.element(rIndex).addAssign(rScalar.mul(pressure));

					})().compute(dispatches);

				}

				const getIndexedValuesFromStorage = ( readBuffer, indices ) => {
					const nodes = [];
					for (let i = 0; i < indices.length; i ++) {
						nodes.push(readBuffer.element(indices[i]));
					}
					return nodes;
				}

				const returnColor = (r, g, b) => {
					return vec3(r, g, b);
				}



				computeIntegration = tslFn(() => {

					const velYWriteBuffer = createWriteStorage(velYStartBufferAttribute, 'float');
					const cellIndex = getCellIndexFromInstanceIndex();
					velYWriteBuffer.element(cellIndex).addAssign(gravityUniform.mul(deltaTimeUniform));

				})().compute(numSimCells);
				

				computeDiv_I0J0 = createDivergenceShader( 0, 0 );
				computeDiv_I0J1 = createDivergenceShader( 0, 1 );
				computeDiv_I1J0 = createDivergenceShader( 1, 0 );
				computeDiv_I1J1 = createDivergenceShader( 1, 1 );

				// Extrapolate velocity of buffer cells from surrounding simulation cells.
				// Effectively a post-processing part of the divergence/outflow/incompressibility step.
				// Shader is a bit of hack, making use of the fact that our grid dimensions are always square.
				computeExtrapolateX = tslFn(() => {
					const velXReadWrite = storage(velXDivergenceBufferAttribute, 'float', 1);

					// Buffer cell to left of first simulation column
					const cellLeftBufferIndex = instanceIndex.mul(bufferCols);
					// Buffer cell to right of last simulation column
					const cellRightBufferIndex = cellLeftBufferIndex.add(bufferCols - 1);

					// Apply horizontal velocity of simulation cells to left and right buffer cells
					const leftBufferVelocity = velXReadWrite.element(cellLeftBufferIndex);
					leftBufferVelocity.assign(velXReadWrite.element(cellLeftBufferIndex.add(1)));

					const rightBufferVelocity = velXReadWrite.element(cellRightBufferIndex);
					rightBufferVelocity.assign(velXReadWrite.element(cellRightBufferIndex.sub(1)));

				})().compute(bufferRows); 

				computeExtrapolateY = tslFn(() => {
					const velYReadWrite = storage(velYDivergenceBufferAttribute, 'float', 1);

					// Buffer cell below first simulation row
					const cellBottomBufferIndex = instanceIndex;
					// Buffer cell above last simulation row
					const cellTopBufferIndex = instanceIndex.add(bufferCols * bufferRows - 1);

					// Apply vertical velocity of simulation cells to top and bottom buffer cells
					const bottomBufferVelocity = velYReadWrite.element(cellBottomBufferIndex);
					bottomBufferVelocity.assign(velYReadWrite.element(cellBottomBufferIndex.add(1)));

					const topBufferVelocity = velYReadWrite.element(cellTopBufferIndex);
					topBufferVelocity.assign(velYReadWrite.element(cellTopBufferIndex.sub(1)));

				})().compute(bufferCols)


				computeAdvection = tslFn(() => {

					



				})

				const createFragmentShader = (r, g, b) => tslFn(() => {

					return vec3(r, g, b);

				})


				const storageFragmentShader = createFragmentShader(1.0, 0.0, 0.0);

				const textureFragmentShader = tslFn(() => {

					returnColor(r, g, b);

				});

				camera = new THREE.OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );
				scene = new THREE.Scene();

				const geometry = new THREE.PlaneGeometry( 2, 2 );

				const simWithStorageQuad = new THREE.Mesh( geometry, new MeshBasicNodeMaterial({
					colorNode: storageFragmentShader(),
				}));
				scene.add( simWithStorageQuad );

				const simWithTextureQuad = new THREE.Mesh( geometry, new MeshBasicNodeMaterial({
					colorNode: textureFragmentShader(),
				}));
				scene.add( simWithTextureQuad );
				simWithTextureQuad.visible = false;

				const params = {
					method: 'storageBuffer'
				};

				const gui = new GUI();

				gui.add(params, 'method', computeMethods).onChange(() => {
					console.log(params.method)

					if (params.method === 'storageBuffer') {

						simWithTextureQuad.visible = false;
						simWithStorageQuad.visible = true;

					}

					if (params.method === 'storageTexture') {
						
						simWithStorageQuad.visible = false;
						simWithTextureQuad.visible = true;

					}

				})
				//renderer.computeAsync( computeInitNode );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function animate() {

				renderer.compute(computeIntegration);

				// Not aware of good mechanism to update uniforms in between compute passes,
				// So for now, we just execute four separate shaders
				for (let i = 0; i < 1; i++) {

					renderer.compute(computeDiv_I0J0);
					renderer.compute(computeDiv_I0J1);
					renderer.compute(computeDiv_I1J0);
					renderer.compute(computeDiv_I1J1);

				} 

				renderer.compute(computeDiv_I0J0);

				renderer.render( scene, camera );

			}

		</script>
	</body>
</html>
