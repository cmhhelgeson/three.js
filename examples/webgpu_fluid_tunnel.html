<html lang="en">
	<head>
		<title>three.js - WebGPU - Fluid Tunnel</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> WebGPU - Fluid Tunnel
		</div>
		<div id="container">
			<canvas id="c"></canvas>
		
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.module.js",
					"three/addons/": "./jsm/",
					"three/nodes": "./jsm/nodes/Nodes.js"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three';
			import { vec2, vec3, vec4, sqrt, sign, radians, atan2, cos, sin, clamp, length, abs, min, max, float, timerLocal, cond, positionGeometry, varying, varyingProperty, floor, uv, remainder, If, tslFn, storageTexture, expression, MeshBasicNodeMaterial, temp, negate, storage, storageReadOnly, wgslFn, code, instanceIndex, uniform, Return, texture, fract } from 'three/nodes';

			import WebGPU from 'three/addons/capabilities/WebGPU.js';
			import WebGPURenderer from 'three/addons/renderers/webgpu/WebGPURenderer.js';
			import StorageTexture from 'three/addons/renderers/common/StorageTexture.js';
			import StorageBufferAttribute from 'three/addons/renderers/common/StorageBufferAttribute.js';

			import { GUI } from 'three/addons/libs/lil-gui.module.min.js';

			let camera, sceneDivergencePlayground, sceneWindTunnel, renderer;
			let computeInitNode, computeToPing, computeToPong;
			let pingTexture, pongTexture;
			let material;
			let phase = true;
			let lastUpdate = - 1;
			let storageFragmentShader, textureFragmentShader;

			// Step 1. Apply gravity to velocity x, y (u, v);
			let computeIntegration;
			// Step 2. Compute divergence, make velocity of each cell incomrpessible
			let computeDiv_I0J0, computeDiv_I0J1, computeDiv_I1J0, computeDiv_I1J1;
			// Step 3. Extrapolate velocities of buffer cells from divergence velocities.
			let computeExtrapolateX, computeExtrapolateY;
			// Step 4. Advection
			let computeAdvection;
			// Step 5. Smoke
			let computeSmoke;

			let raycaster, mouse, highlightedInstanceId;

			const dummy = new THREE.Object3D();

			const computeMethods = {
				'Storage Texture': 'storageTexture',
				'Storage Buffer': 'storageBuffer',
			}

			const SCENE_DIVERGENCE_PLAYGROUND = 0;
			const SCENE_WIND_TUNNEL = 1;

			let currentSceneIndex = 0;

			const canvas = document.getElementById('c');

			// Uniform across all scenes
			let simHeight, cScale, simWidth, domainHeight, domainWidth, res;

			const createTSLColorOutput = (r, g, b) => tslFn(() => {

					return vec3(r, g, b);

			})

			const getSimGridDimensions = (h) => {

				const simCols = Math.floor(domainWidth / h);
				const simRows = Math.floor(domainHeight / h);
				console.log(`simCols: ${simCols}, simRows: ${simRows}`);
				const numSimCells = simCols * simRows;

				return {
					simCols,
					simRows,
					numSimCells
				};

			}

			const getBufferGridDimensions = ( simCols, simRows, cellBuffer ) => {

				const buffer = cellBuffer * 2;
				const bufferCols = simCols + buffer;
				const bufferRows = simRows + buffer;
				console.log(`bufferCols: ${bufferCols}, bufferRows: ${bufferRows}`);
				const numBufferCells = bufferCols * bufferRows;

				return {bufferCols, bufferRows, numBufferCells};

			}

			const setupSceneDivergencePlayground = () => {

				const res = 10;
				const h = domainHeight / res;
				const {simCols, simRows, numSimCells} = getSimGridDimensions(h);
				const {bufferCols, bufferRows, numBufferCells} = getBufferGridDimensions(simCols, simRows, 1);
				const velXBufferAttribute = new StorageBufferAttribute(numBufferCells, 1);
				const velYBufferAttribute = new StorageBufferAttribute(numBufferCells, 1);
				console.log(velXBufferAttribute)
				
				for (let i = 0; i < numBufferCells; i++) {
					velXBufferAttribute.array[i] = Math.random() * 3;
					velYBufferAttribute.array[i] = Math.random() * 3;
				}

				console.log(velXBufferAttribute);
				

				sceneDivergencePlayground = new THREE.Scene();

				const quadWidth = 2 / simCols;
				const quadHeight = 2 / simRows;

				//const geometry = new THREE.PlaneGeometry(quadWidth, quadHeight);
				const geometry = new THREE.PlaneGeometry(2, 2);
				const vInstance = varyingProperty('uint', 'vInstance')
				const instancedPositionNode = tslFn(() => {
					return positionGeometry;
				})

				const textureLoader = new THREE.TextureLoader()
				const waterTexture = textureLoader.load('textures/water/WaterTexture.png');
				waterTexture.wrapS = THREE.RepeatWrapping;
				waterTexture.wrapT = THREE.RepeatWrapping;
				
				const instancedColorNode = tslFn(() => {
					const velXRead = storageReadOnly(velXBufferAttribute, 'float', numSimCells);
					const velYRead = storageReadOnly(velYBufferAttribute, 'float', numSimCells);

					const samplePoint = temp(uv(), 'samplePoint');
					samplePoint.x = samplePoint.x.add(timerLocal().mul(velXRead.element(vInstance)));
					samplePoint.y = samplePoint.y.add(timerLocal().mul(velYRead.element(vInstance)));
					
					const textureColor = texture(waterTexture, samplePoint);
					const testColor = float(1.0).sub(float(vInstance).div(100));
					return textureColor;
				})

				const sdfCircle = (
					pointNode,
					radius
				) => {
					const l = length(pointNode).sub(radius);
					return l;
				}

				const rotateUV = (
					pointNode,
					angleNode
				) => {
					const cosAngle = cos(angleNode);
					const sinAngle = sin(angleNode);

					return vec2(
						cosAngle.mul(pointNode.x).add(sinAngle.mul(pointNode.y)),
						negate(sinAngle).mul(pointNode.x).add(cosAngle.mul(pointNode.y))
					)
				}
				

				const sdfEquilateralTriangle = (
					uvNode,
					radiusNode,
					offsetNode,
				) => {
					const p = uvNode;
					p.addAssign(offsetNode)
					

					const r = radiusNode;

					const k = sqrt( 3.0 );
					p.x.assign( abs( p.x ).sub( r ) );
					p.y.assign(p.y.add(r.div(k)));

					If(p.x.add(k.mul(p.y)).greaterThan(0.0), () => {
						const x = p.x.sub(k.mul(p.y));
						const y = negate(k).mul(p.x);
						y.subAssign(p.y);
						p.assign(vec2(x, y).div(2.0));
					})

					p.x.subAssign(clamp(p.x, r.mul(-2.0), 0.0));
					
					return negate(length(p).mul(sign(p.y)));

				}

				const sdfBox = (
					uvNode,
					dimensionsNode
				) => {
					const d = abs( uvNode ).sub( dimensionsNode );
					return length( max( d, float(0.0) ) ).add( min( max( d.x, d.y ), 0.0 ) )
				}

				const divergenceFragmentNode = tslFn(() => {
					const velXRead = storageReadOnly( velXBufferAttribute, 'float', numBufferCells );
					const velYRead = storageReadOnly( velYBufferAttribute, 'float', numBufferCells );

					const uvGrid = temp( uv().mul( vec2( simCols, simRows ) ), 'uvGrid' );
					const simGrid2DIndex = temp( floor( uvGrid ), 'simGrid2DIndex' );
					const bufferGrid2DIndex = temp( simGrid2DIndex.add( 1 ), 'bufferGrid2DIndex' );
					
					const cellIndex = temp( bufferGrid2DIndex.x.add( bufferGrid2DIndex.y.mul( bufferCols ) ), 'cellIndex' );

					const velX = velXRead.element(cellIndex);
					const velY = velYRead.element(cellIndex);


					const samplePoint = temp(
						vec2(
							fract(uvGrid.x.add( timerLocal().mul( velX ) )),
							fract(uvGrid.y.add( timerLocal().mul( velY ) ))
						),
						'samplePoint'
					);

					// Get 0 to 1 uv coordinates of each cell
					const uvCell = fract(uvGrid);
					// Get -1 to 1 uv coordinates of each cell
					const uvCellNDC = uvCell.mul(2.0).sub(1.0);
					// Add angle in radians between x-axis and velocity vector
					const angle = atan2(velY, velX)
					// Set base rotation to allign with x axis
					angle.subAssign(radians(-90.0))
					// Rotate uv coordinates by angle determined by velocity. 
					const uvCellNDCRotated = rotateUV(uvCellNDC, angle);
					// For some reason uvCellNDCRotated only works for box when it's written inline
					const dBox = sdfBox(rotateUV(uvCell.mul(2.0).sub(1.0), angle), vec2(0.05, 0.6));
					const dTriangle = sdfEquilateralTriangle(uvCellNDCRotated, float(0.2), vec2(0.0, -0.5));
					const d = min(dBox, dTriangle);
					const check = temp(d.lessThan(0.0), 'check');
					const textureColor = temp(
						texture(waterTexture, samplePoint),
						'textureColor'
					);

					const otherColor = temp(
						vec4(1.0, 1.0, 1.0, 1.0),
						'otherColor'
					)

					textureColor.x.addAssign(otherColor.x.mul(check));
					textureColor.y.addAssign(otherColor.y.mul(check));
					textureColor.z.addAssign(otherColor.z.mul(check))

					//const test = d.lessThan(0.0).cond(textureColor, otherColor)
						
					

					return textureColor;
				})
				const instancedMeshMaterial = new MeshBasicNodeMaterial();
				instancedMeshMaterial.positionNode = instancedPositionNode();
				instancedMeshMaterial.colorNode = divergenceFragmentNode();
				const mesh = new THREE.Mesh(geometry, instancedMeshMaterial);
				sceneDivergencePlayground.add(mesh)


			}

			function init() {

				if ( WebGPU.isAvailable() === false ) {

					document.body.appendChild( WebGPU.getErrorMessage() );

					throw new Error( 'No WebGPU support' );

				}
				
				// Create renderer
				renderer = new WebGPURenderer( { antialias: true, canvas: canvas} );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				document.body.appendChild( renderer.domElement );
				window.addEventListener( 'resize', onWindowResize );

				// Create simulation height
				simHeight = 1.0
				cScale = canvas.height / simHeight;
				simWidth = canvas.width / cScale;
				domainHeight = 1.0;
				domainWidth = domainHeight / simHeight * simWidth;
				const res = 100;
				const h = domainHeight / res;

				mouse = new THREE.Vector2();
				raycaster = new THREE.Raycaster();
				highlightedInstanceId = null;

				

				setupSceneDivergencePlayground();

				// For now try to use same camera for each scene
				camera = new THREE.OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );


				const {simCols, simRows, numSimCells} = getSimGridDimensions(h);
				const {bufferCols, bufferRows, numBufferCells} = getBufferGridDimensions(simCols, simRows, 1);

				// Velocity x (or u) located at center of left side of grid cell
				const velXStartBufferAttribute = new StorageBufferAttribute( numBufferCells, 1 );
				const velXDivergenceBufferAttribute = new StorageBufferAttribute( numBufferCells, 1 );
				const velXAdvectionBufferAttribute = new StorageBufferAttribute( numBufferCells, 1 );
				// Velocity y (or v) located at center of bottom side of grid cell
				const velYStartBufferAttribute = new StorageBufferAttribute( numBufferCells, 1 );
				const velYDivergenceBufferAttribute = new StorageBufferAttribute( numBufferCells, 1 );
				const velYAdvectionBufferAttribute = new StorageBufferAttribute( numBufferCells, 1 );

				const pressureBufferAttribute = new StorageBufferAttribute( numBufferCells, 1 );
				const dBufferAttribute = new StorageBufferAttribute( numBufferCells, 1 );
				const scalarBufferAttribute = new StorageBufferAttribute( numBufferCells, 1 );

				const overRelaxationUniform = uniform(1.9);
				const cpUniform = uniform(1000)
				const densityUniform = uniform(1000);

				const deltaTimeUniform = uniform( 1 / 120.0 );
				const gravityUniform = uniform( -9.81 );

				const createReadStorage = ( attribute, type ) => storageReadOnly( attribute, type, numBufferCells);
				// Technically read-write storage
				const createWriteStorage = ( attribute, type ) => storage( attribute, type, numBufferCells );

				const getCellIndexFromInstanceIndex = () => {

					// 2D index of sim grid cell (x, y)
					const simGridCol = temp(instanceIndex.remainder(simCols), 'simGridX');
					const simGridRow = temp(instanceIndex.div(simCols), 'simGridY');
					// 2D index of sim grid cell in buffered grid (x, y)
					const bufferGridCol = temp(simGridCol.add(1), 'bufferGridX');
					const bufferGridRow = temp(simGridRow.add(1), 'bufferGridY');

					// Convert to 1D index into buffered grid for storage buffer access
					return temp(bufferGridCol.add(bufferGridRow.mul(bufferCols)), 'cellIndex');

				}

				const getOffsetCellIndex = (dispatchesX, offsetX, offsetY) => {

					// Work in the coordinates of our non-adjacent cells compressed together into a separate grid
					// In a 2d compute execution context, these are analagous with the x and y ids of our threads
					const compactGridCol = temp(instanceIndex.remainder(dispatchesX), 'compactGridX');
					const compactGridRow = temp(instanceIndex.div(dispatchesX), 'compactGridY' );

					// Get location of compact grid cell in sim grid cell space
					const simGridCol = compactGridCol.mul(2).add(offsetX);
					const simGridRow = compactGridRow.mul(2).add(offsetY);

					// Get index of sim grid cell in buffer grid (x, y)
					const bufferGridCol = temp(simGridCol.add(1), 'bufferGridX');
					const bufferGridRow = temp(simGridRow.add(1), 'bufferGridY');

					// Convert to 1D index into buffered grid for storage buffer access
					return temp(
						bufferGridCol.add(bufferGridRow.mul(bufferCols)),
						'cellIndex',
					);

				}

				const calculateDivergenceStepDispatches = (numCols, numRows, offsetX, offsetY) => {
					const dispatchX = Math.floor( (numCols + 1 - offsetX) / 2);
					const dispatchY = Math.floor( (numRows + 1 - offsetY) / 2);
					return { dispatchX, dispatchY };
				}

				const testDivergenceSteps = (numCols, numRows) => {
					console.log(calculateDivergenceStepDispatches(numCols, numRows, 0, 0));
					console.log(calculateDivergenceStepDispatches(numCols, numRows, 1, 0))
					console.log(calculateDivergenceStepDispatches(numCols, numRows, 0, 1))
					console.log(calculateDivergenceStepDispatches(numCols, numRows, 1, 1))
				}

				testDivergenceSteps(6, 6);

				const createDivergenceShader = (offsetX, offsetY) => {

					const {dispatchX, dispatchY} = calculateDivergenceStepDispatches(simCols, simRows, offsetX, offsetY);
					const dispatches = dispatchX * dispatchY;

					return tslFn(() => {
					// Create shader storage buffers
						const velXRead = createReadStorage( velXStartBufferAttribute, 'float');
						const velYRead = createReadStorage( velXStartBufferAttribute, 'float');

						const velXWrite = createWriteStorage( velXDivergenceBufferAttribute, 'float');
						const velYWrite = createWriteStorage( velYDivergenceBufferAttribute, 'float');

						const pressureWrite = createWriteStorage( pressureBufferAttribute, 'float');
						const scalarRead = createReadStorage( scalarBufferAttribute, 'uint');

						const cellIndex = getOffsetCellIndex(dispatchX, offsetX, offsetY);
					
						// No need for boundary checks since our cellIndex is buffered
						const lIndex = temp(cellIndex.sub(1), 'cellLeftIndex');
						const rIndex = temp(cellIndex.add(1), 'cellRightIndex');
						const uIndex = temp(cellIndex.add(bufferCols), 'cellAboveIndex');
						const bIndex = temp(cellIndex.sub(bufferCols), 'cellBelowIndex');

						const [lScalar, rScalar, uScalar, bScalar] = getIndexedValuesFromStorage(scalarRead, [lIndex, rIndex, uIndex, bIndex]);

						const cellScalar = temp(lScalar.add(rScalar).add(uScalar).add(bScalar), 'cellScalar');

						If(cellScalar.equal(0.0), () => {
							Return();
						});

						// Subtract inflow of current cell from inflow of adjacent cells to get the outflow.
						// Current cell inflow represents negative outflow from current cell.
						const currentCellInflowX = temp(velXRead.element(cellIndex), 'currentCellInflowX');
						const currentCellInflowY = temp(velYRead.element(cellIndex), 'currentCellInflowY');
						const currentCellInflow = temp(currentCellInflowX.add(currentCellInflowY), 'currentCellInflow');

						// Adjacent cell inflow represents positive outflow from current cell.
						const adjacentCellInflowX = velXRead.element(rIndex);
						const adjacentCellInflowY = velYRead.element(uIndex);
						const adjacentCellInflow = temp(adjacentCellInflowX.add(adjacentCellInflowY), 'adjacentCellInfow');

						const outflow = temp(adjacentCellInflow.sub(currentCellInflow), 'outflow');
						const negativeOutflow = outflow.sub(outflow.mul(2))
					
						let pressure = negativeOutflow.div(cellScalar);
						pressure.mulAssign(overRelaxationUniform);
					
						pressureWrite.element(cellIndex).addAssign(pressure);

						// Apply scalars to cell velocities
						// Velocity X
						velXWrite.element(cellIndex).subAssign(lScalar.mul(pressure));
						velXWrite.element(rIndex).addAssign(rScalar.mul(pressure));
						// Velocity Y
						velYWrite.element(cellIndex).subAssign(bScalar.mul(pressure));
						velXWrite.element(rIndex).addAssign(rScalar.mul(pressure));

					})().compute(dispatches);

				}

				const getIndexedValuesFromStorage = ( readBuffer, indices ) => {
					const nodes = [];
					for (let i = 0; i < indices.length; i ++) {
						nodes.push(readBuffer.element(indices[i]));
					}
					return nodes;
				}

				const returnColor = (r, g, b) => {
					return vec3(r, g, b);
				}



				computeIntegration = tslFn(() => {

					const velYWriteBuffer = createWriteStorage(velYStartBufferAttribute, 'float');
					const cellIndex = getCellIndexFromInstanceIndex();
					velYWriteBuffer.element(cellIndex).addAssign(gravityUniform.mul(deltaTimeUniform));

				})().compute(numSimCells);
				

				computeDiv_I0J0 = createDivergenceShader( 0, 0 );
				computeDiv_I0J1 = createDivergenceShader( 0, 1 );
				computeDiv_I1J0 = createDivergenceShader( 1, 0 );
				computeDiv_I1J1 = createDivergenceShader( 1, 1 );

				// Extrapolate velocity of buffer cells from surrounding simulation cells.
				// Effectively a post-processing part of the divergence/outflow/incompressibility step.
				// Shader is a bit of hack, making use of the fact that our grid dimensions are always square.
				computeExtrapolateX = tslFn(() => {
					const velXReadWrite = storage(velXDivergenceBufferAttribute, 'float', 1);

					// Buffer cell to left of first simulation column
					const cellLeftBufferIndex = instanceIndex.mul(bufferCols);
					// Buffer cell to right of last simulation column
					const cellRightBufferIndex = cellLeftBufferIndex.add(bufferCols - 1);

					// Apply horizontal velocity of simulation cells to left and right buffer cells
					const leftBufferVelocity = velXReadWrite.element(cellLeftBufferIndex);
					leftBufferVelocity.assign(velXReadWrite.element(cellLeftBufferIndex.add(1)));

					const rightBufferVelocity = velXReadWrite.element(cellRightBufferIndex);
					rightBufferVelocity.assign(velXReadWrite.element(cellRightBufferIndex.sub(1)));

				})().compute(bufferRows); 

				computeExtrapolateY = tslFn(() => {
					const velYReadWrite = storage(velYDivergenceBufferAttribute, 'float', 1);

					// Buffer cell below first simulation row
					const cellBottomBufferIndex = instanceIndex;
					// Buffer cell above last simulation row
					const cellTopBufferIndex = instanceIndex.add(bufferCols * bufferRows - 1);

					// Apply vertical velocity of simulation cells to top and bottom buffer cells
					const bottomBufferVelocity = velYReadWrite.element(cellBottomBufferIndex);
					bottomBufferVelocity.assign(velYReadWrite.element(cellBottomBufferIndex.add(1)));

					const topBufferVelocity = velYReadWrite.element(cellTopBufferIndex);
					topBufferVelocity.assign(velYReadWrite.element(cellTopBufferIndex.sub(1)));

				})().compute(bufferCols)


				computeAdvection = tslFn(() => {

					



				})


				const storageFragmentShader = createTSLColorOutput(1.0, 0.0, 0.0);

				const textureFragmentShader = tslFn(() => {

					returnColor(r, g, b);

				});

				camera = new THREE.OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );
				sceneWindTunnel = new THREE.Scene();

				const geometry = new THREE.PlaneGeometry( 2, 2 );

				const simWithStorageQuad = new THREE.Mesh( geometry, new MeshBasicNodeMaterial({
					colorNode: storageFragmentShader(),
				}));
				sceneWindTunnel.add( simWithStorageQuad );

				const simWithTextureQuad = new THREE.Mesh( geometry, new MeshBasicNodeMaterial({
					colorNode: textureFragmentShader(),
				}));
				sceneWindTunnel.add( simWithTextureQuad );
				simWithTextureQuad.visible = false;

				const params = {
					method: 'storageBuffer'
				};

				const gui = new GUI();

				gui.add(params, 'method', computeMethods).onChange(() => {
					console.log(params.method)

					if (params.method === 'storageBuffer') {

						simWithTextureQuad.visible = false;
						simWithStorageQuad.visible = true;

					}

					if (params.method === 'storageTexture') {
						
						simWithStorageQuad.visible = false;
						simWithTextureQuad.visible = true;

					}

				})

				renderer.setAnimationLoop( animate );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function animate() {

				if (currentSceneIndex === 0) {

					renderer.render(sceneDivergencePlayground, camera)

				} else {

					renderer.compute(computeIntegration);

					// Not aware of good mechanism to update uniforms in between compute passes,
					// So for now, we just execute four separate shaders
					for (let i = 0; i < 1; i++) {

						renderer.compute(computeDiv_I0J0);
						renderer.compute(computeDiv_I0J1);
						renderer.compute(computeDiv_I1J0);
						renderer.compute(computeDiv_I1J1);

					} 

					// renderer.compute(computeExtrapolateX)
					// renderer.compute(computeExtrapolateY)
					// renderer.compute(computeAdvection)
					// renderer.compute(computeSmoke)

					renderer.render( sceneWindTunnel, camera );

				}

			}

			init();

		</script>
	</body>
</html>
