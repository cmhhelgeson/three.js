<html lang="en">
	<head>
		<title>three.js - WebGPU - Fluid Tunnel</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> WebGPU - Fluid Tunnel
		</div>
		<div id="container">
			<canvas id="c"></canvas>
		
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.module.js",
					"three/addons/": "./jsm/",
					"three/nodes": "./jsm/nodes/Nodes.js"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three';
			// In TSL, unless directly operating on a node, nearly every function you deploy needs to be imported from Nodes.js
			import { vec2, vec3, vec4, sqrt, sign, mix, smoothstep, radians, atan2, cos, sin, clamp, length, abs, min, max, float, timerLocal, cond, positionGeometry, varying, varyingProperty, floor, uv, remainder, If, tslFn, storageTexture, expression, MeshBasicNodeMaterial, temp, negate, storage, storageReadOnly, wgslFn, code, instanceIndex, uniform, Return, texture, fract } from 'three/nodes';
			import WebGPU from 'three/addons/capabilities/WebGPU.js';
			import WebGPURenderer from 'three/addons/renderers/webgpu/WebGPURenderer.js';
			import StorageTexture from 'three/addons/renderers/common/StorageTexture.js';
			import StorageBufferAttribute from 'three/addons/renderers/common/StorageBufferAttribute.js';
			import { GUI } from 'three/addons/libs/lil-gui.module.min.js';

			// Define general Three.js objects
			// Same orthographic camera and WebGPU renderer used across both scenes.
			let camera, renderer;

			// Scene 0: View divergence adjustment in isolation
			// Scene 1: Wind tunnel fluid simulation.
			let sceneDivergencePlayground, sceneWindTunnel;
			const SCENE_DIVERGENCE_PLAYGROUND = 0;
			const SCENE_WIND_TUNNEL = 1;
			let currentSceneIndex = 0;

			// Will the wind tunnel fragment shader pull its velocity from a storage texture or a storage buffer?
			let storageFragmentShader, textureFragmentShader;
			const computeMethods = {
				'Storage Texture': 'storageTexture',
				'Storage Buffer': 'storageBuffer',
			}

			// Scene 0 Specific Constants
			const outflowIndicatorMaxRadius = 0.5;

			// Define the compute shaders that will perform our per-frame fluid simulation
			// Step 1. Apply gravity to velocity x, y (u, v);
			let computeIntegration;
			// Step 2. Compute divergence, make velocity of each cell incompressible (used in divergence playground as well)
			let computeDiv_I0J0, computeDiv_I0J1, computeDiv_I1J0, computeDiv_I1J1;
			// Step 3. Extrapolate velocities of buffer cells from divergence velocities.
			let computeExtrapolateX, computeExtrapolateY;
			// Step 4. Advect velocities;
			let computeAdvection;
			// Step 5. Advect smoke;
			let computeSmoke;

			const canvas = document.getElementById('c');

			// Uniform across all scenes
			let simHeight, cScale, simWidth, domainHeight, domainWidth, res;

			// UTILITY FUNCTIONS
			// Functions designated for use in TSL blocks have TSL appended to their names.

			// Indexing utility functions
			const getSimGridDimensions = (h) => {

				const simCols = Math.floor( domainWidth / h );
				const simRows = Math.floor( domainHeight / h );
				console.log(`simCols: ${simCols}, simRows: ${simRows}`);
				const numSimCells = simCols * simRows;
				return { simCols, simRows, numSimCells };

			}

			const getBufferGridDimensions = ( simCols, simRows, cellBuffer ) => {

				const buffer = cellBuffer * 2;
				const bufferCols = simCols + buffer;
				const bufferRows = simRows + buffer;
				console.log(`bufferCols: ${bufferCols}, bufferRows: ${bufferRows}`);
				const numBufferCells = bufferCols * bufferRows;
				return {bufferCols, bufferRows, numBufferCells};

			}

			const getCellIndexFromInstanceIndex = ( index, simCols, bufferCols ) => {

				const simGridX = index % simCols;
				const simGridY = Math.floor(index / simCols);
				const bufferGridX = simGridX + 1;
				const bufferGridY = simGridY + 1;
				console.log(simGridX, simGridY, bufferGridX, bufferGridY, bufferGridY * bufferCols)
				return bufferGridY * bufferCols + bufferGridX;

			}

			const getCellIndexFromInstanceIndexTSL = ( simCols, bufferCols ) => {

				// 2D index of sim grid cell (x, y)
				const simGridCol = temp(instanceIndex.remainder(simCols), 'simGridX');
				const simGridRow = temp(instanceIndex.div(simCols), 'simGridY');
				// 2D index of sim grid cell in buffered grid (x, y)
				const bufferGridCol = temp(simGridCol.add(1), 'bufferGridX');
				const bufferGridRow = temp(simGridRow.add(1), 'bufferGridY');
				// Convert to 1D index into buffered grid for storage buffer access
				return temp(bufferGridCol.add(bufferGridRow.mul(bufferCols)), 'cellIndex');

			}

			// Fragment shader utility functions
			const rotateUVTSL = ( pointNode, angleNode ) => {

				const cosAngle = cos( angleNode );
				const sinAngle = sin( angleNode );
				const rotateX = cosAngle.mul( pointNode.x ).add( sinAngle.mul( pointNode.y ) );
				const rotateY = negate( sinAngle ).mul( pointNode.x ).add( cosAngle.mul( pointNode.y ) );
				return vec2( rotateX, rotateY );

			}

			const sdfCircleTSL = ( pointNode, radiusNode ) => {

				return length(pointNode).sub(radiusNode);

			}

			const sdfBoxTSL = ( uvNode, dimensionsNode ) => {

				const d = abs( uvNode ).sub( dimensionsNode );
				return length( max( d, float(0.0) ) ).add( min( max( d.x, d.y ), 0.0 ) )

			}

			const sdfEquilateralTriangleTSL = ( uvNode, radiusNode, offsetNode ) => {

				const p = uvNode;
				p.addAssign(offsetNode)
				const r = radiusNode;
				const k = sqrt( 3.0 );
				p.x.assign( abs( p.x ).sub( r ) );
				p.y.assign(p.y.add(r.div(k)));
				If(p.x.add(k.mul(p.y)).greaterThan(0.0), () => {

					const x = p.x.sub(k.mul(p.y));
					const y = negate(k).mul(p.x);
					y.subAssign(p.y);
					p.assign(vec2(x, y).div(2.0));

				})

				p.x.subAssign(clamp(p.x, r.mul(-2.0), 0.0));
				return negate(length(p).mul(sign(p.y)));

			}

			const createColorOutputTSL = (r, g, b) => tslFn(() => {

					return vec3(r, g, b);

			})

			const setupSceneDivergencePlayground = () => {

				const res = 10;
				const h = domainHeight / res;
				const {simCols, simRows, numSimCells} = getSimGridDimensions(h);
				const {bufferCols, bufferRows, numBufferCells} = getBufferGridDimensions(simCols, simRows, 1);
				const velXBufferAttribute = new StorageBufferAttribute(numBufferCells, 1);
				const velYBufferAttribute = new StorageBufferAttribute(numBufferCells, 1);
				const divergenceBufferAttribute = new StorageBufferAttribute(numBufferCells, 1);
				
				// Randomize velocity values
				for (let i = 0; i < numSimCells; i++) {
					const cellIndex = getCellIndexFromInstanceIndex(i, simCols, bufferCols);
					velXBufferAttribute.array[cellIndex] = Math.random() * 4 - 2;
					velYBufferAttribute.array[cellIndex] = Math.random() * 4 - 2;
				}

				// Calculate current divergence/outflow based on randomized velocity values
				for (let i = 0; i < numSimCells; i++) {

					const cellIndex = getCellIndexFromInstanceIndex(i, simCols, bufferCols);
					const lIndex = cellIndex - 1;
					const rIndex = cellIndex + 1;
					const uIndex = cellIndex + bufferCols;
					const bIndex = cellIndex - bufferCols;

					const inflowIntoCell = velXBufferAttribute.array[i] + velYBufferAttribute.array[i];
					const outflowOutOfCell = velXBufferAttribute.array[rIndex] + velYBufferAttribute.array[uIndex];

					divergenceBufferAttribute.array[cellIndex] = outflowOutOfCell - inflowIntoCell;

				}

				console.log(velXBufferAttribute.array);
				console.log(velYBufferAttribute.array);
				console.log(divergenceBufferAttribute.array)
				
				sceneDivergencePlayground = new THREE.Scene();

				const quadWidth = 2 / simCols;
				const quadHeight = 2 / simRows;

				//const geometry = new THREE.PlaneGeometry(quadWidth, quadHeight);
				const geometry = new THREE.PlaneGeometry(2, 2);

				const textureLoader = new THREE.TextureLoader()
				const waterTexture = textureLoader.load('textures/water/WaterTexture.png');
				waterTexture.wrapS = THREE.RepeatWrapping;
				waterTexture.wrapT = THREE.RepeatWrapping;
				
				// Create color constants
				const white = vec4(1.0, 1.0, 1.0, 1.0);
				const green = vec4(0.0, 1.0, 0.0, 1.0);
				
				const divergenceFragmentNode = tslFn(() => {

					const velXRead = storageReadOnly( velXBufferAttribute, 'float', numBufferCells );
					const velYRead = storageReadOnly( velYBufferAttribute, 'float', numBufferCells );
					const uvGrid = temp( uv().mul( vec2( simCols, simRows ) ), 'uvGrid' );
					// 2D Coordinate in Simulation Grid
					const simGrid2DIndex = temp( floor( uvGrid ), 'simGrid2DIndex' );
					// 2D Coordinate in Buffer Grid
					const bufferGrid2DIndex = temp( simGrid2DIndex.add( 1 ), 'bufferGrid2DIndex' );
					// 1D Coordinate in Buffer Grid
					const cellIndex = temp( bufferGrid2DIndex.x.add( bufferGrid2DIndex.y.mul( bufferCols ) ), 'cellIndex' );
				
					const velX = velXRead.element(cellIndex);
					const velY = velYRead.element(cellIndex);

					const samplePoint = temp(
						vec2(
							fract(uvGrid.x.add( timerLocal().mul( velX ) )),
							fract(uvGrid.y.add( timerLocal().mul( velY ) ))
						),
						'samplePoint'
					);

					// Get 0 to 1 uv coordinates of each cell
					const uvCell = fract(uvGrid);
					// Get -1 to 1 uv coordinates of each cell
					const uvCellNDC = uvCell.mul(2.0).sub(1.0);
					// Add angle in radians between x-axis and velocity vector
					const angle = atan2(velY, velX)
					// Set base rotation to allign with x axis
					angle.subAssign(radians(-90.0))
					// Rotate uv coordinates by angle determined by velocity. 
					const uvCellNDCRotated = rotateUVTSL(uvCellNDC, angle);
					// For some reason uvCellNDCRotated only works for box when it's written inline
					const boxSDF = sdfBoxTSL(rotateUVTSL(uvCell.mul(2.0).sub(1.0), angle), vec2(0.05, 0.6));
					const triangleSDF = sdfEquilateralTriangleTSL(uvCellNDCRotated, float(0.2), vec2(0.0, -0.5));
					// Combine box and triangle into arrow
					const arrowSDF = min(boxSDF, triangleSDF);
					const arrowCheck = temp(arrowSDF.lessThan(0.0), 'check');
					const circleSDF = min(sdfCircleTSL(uvCellNDC, outflowIndicatorMaxRadius), 0.01);
					const circleCheck = circleSDF.greaterThan(0.0);
					const textureColor = temp(
						texture(waterTexture, samplePoint),
						'textureColor'
					);

					const alpha = clamp(float(10.0).mul(float(1.0).sub(circleSDF)), 0.0, 1.0);
					const testGreen = vec4(0.0, 1.0, 0.0, alpha);
					const premultipliedGreen = vec4(green.rgb.mul(green.a), green.a);


					// Apply outflow indicator to color (green for outflow/production, black for inflow/destruction)
					textureColor.x.assign(circleCheck.cond(textureColor.x, 0.0));
					textureColor.y.assign(circleCheck.cond(textureColor.y, green.y));
					textureColor.z.assign(circleCheck.cond(textureColor.z, 0.0));

					// Apply Arrow SDF to color
					textureColor.addAssign(white.mul(arrowCheck));
						
					return textureColor;
				})

				const instancedMeshMaterial = new MeshBasicNodeMaterial();
				instancedMeshMaterial.colorNode = divergenceFragmentNode();
				const mesh = new THREE.Mesh(geometry, instancedMeshMaterial);
				sceneDivergencePlayground.add(mesh)


			}

			function init() {

				if ( WebGPU.isAvailable() === false ) {

					document.body.appendChild( WebGPU.getErrorMessage() );

					throw new Error( 'No WebGPU support' );

				}
				
				// Create renderer
				renderer = new WebGPURenderer( { antialias: true, canvas: canvas} );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				document.body.appendChild( renderer.domElement );
				window.addEventListener( 'resize', onWindowResize );

				// Create simulation height
				simHeight = 1.0
				cScale = canvas.height / simHeight;
				simWidth = canvas.width / cScale;
				domainHeight = 1.0;
				domainWidth = domainHeight / simHeight * simWidth;
				const res = 100;
				const h = domainHeight / res;


				

				setupSceneDivergencePlayground();

				// For now try to use same camera for each scene
				camera = new THREE.OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );


				const {simCols, simRows, numSimCells} = getSimGridDimensions(h);
				const {bufferCols, bufferRows, numBufferCells} = getBufferGridDimensions(simCols, simRows, 1);

				// Velocity x (or u) located at center of left side of grid cell
				const velXStartBufferAttribute = new StorageBufferAttribute( numBufferCells, 1 );
				const velXDivergenceBufferAttribute = new StorageBufferAttribute( numBufferCells, 1 );
				const velXAdvectionBufferAttribute = new StorageBufferAttribute( numBufferCells, 1 );
				// Velocity y (or v) located at center of bottom side of grid cell
				const velYStartBufferAttribute = new StorageBufferAttribute( numBufferCells, 1 );
				const velYDivergenceBufferAttribute = new StorageBufferAttribute( numBufferCells, 1 );
				const velYAdvectionBufferAttribute = new StorageBufferAttribute( numBufferCells, 1 );

				const pressureBufferAttribute = new StorageBufferAttribute( numBufferCells, 1 );
				const dBufferAttribute = new StorageBufferAttribute( numBufferCells, 1 );
				const scalarBufferAttribute = new StorageBufferAttribute( numBufferCells, 1 );

				const overRelaxationUniform = uniform(1.9);
				const cpUniform = uniform(1000)
				const densityUniform = uniform(1000);

				const deltaTimeUniform = uniform( 1 / 120.0 );
				const gravityUniform = uniform( -9.81 );

				const createReadStorage = ( attribute, type ) => storageReadOnly( attribute, type, numBufferCells);
				// Technically read-write storage
				const createWriteStorage = ( attribute, type ) => storage( attribute, type, numBufferCells );

				const getOffsetCellIndex = ( dispatchesX, offsetX, offsetY ) => {

					// Work in the coordinates of our non-adjacent cells compressed together into a separate grid
					// In a 2d compute execution context, these are analagous with the x and y ids of our threads
					const compactGridCol = temp(instanceIndex.remainder(dispatchesX), 'compactGridX');
					const compactGridRow = temp(instanceIndex.div(dispatchesX), 'compactGridY' );

					// Get location of compact grid cell in sim grid cell space
					const simGridCol = compactGridCol.mul(2).add(offsetX);
					const simGridRow = compactGridRow.mul(2).add(offsetY);

					// Get index of sim grid cell in buffer grid (x, y)
					const bufferGridCol = temp(simGridCol.add(1), 'bufferGridX');
					const bufferGridRow = temp(simGridRow.add(1), 'bufferGridY');

					// Convert to 1D index into buffered grid for storage buffer access
					return temp(
						bufferGridCol.add(bufferGridRow.mul(bufferCols)),
						'cellIndex',
					);

				}

				const calculateDivergenceStepDispatches = (numCols, numRows, offsetX, offsetY) => {
					const dispatchX = Math.floor( (numCols + 1 - offsetX) / 2);
					const dispatchY = Math.floor( (numRows + 1 - offsetY) / 2);
					return { dispatchX, dispatchY };
				}

				const testDivergenceSteps = (numCols, numRows) => {
					console.log(calculateDivergenceStepDispatches(numCols, numRows, 0, 0));
					console.log(calculateDivergenceStepDispatches(numCols, numRows, 1, 0))
					console.log(calculateDivergenceStepDispatches(numCols, numRows, 0, 1))
					console.log(calculateDivergenceStepDispatches(numCols, numRows, 1, 1))
				}

				testDivergenceSteps(6, 6);

				const createDivergenceShader = ( offsetX, offsetY ) => {

					const {dispatchX, dispatchY} = calculateDivergenceStepDispatches(simCols, simRows, offsetX, offsetY);
					const dispatches = dispatchX * dispatchY;

					return tslFn(() => {
					// Create shader storage buffers
						const velXRead = createReadStorage( velXStartBufferAttribute, 'float');
						const velYRead = createReadStorage( velXStartBufferAttribute, 'float');

						const velXWrite = createWriteStorage( velXDivergenceBufferAttribute, 'float');
						const velYWrite = createWriteStorage( velYDivergenceBufferAttribute, 'float');

						const pressureWrite = createWriteStorage( pressureBufferAttribute, 'float');
						const scalarRead = createReadStorage( scalarBufferAttribute, 'uint');

						const cellIndex = getOffsetCellIndexTSL( dispatchX, offsetX, offsetY );
					
						// No need for boundary checks since our cellIndex is buffered
						const lIndex = temp(cellIndex.sub(1), 'cellLeftIndex');
						const rIndex = temp(cellIndex.add(1), 'cellRightIndex');
						const uIndex = temp(cellIndex.add(bufferCols), 'cellAboveIndex');
						const bIndex = temp(cellIndex.sub(bufferCols), 'cellBelowIndex');

						const [lScalar, rScalar, uScalar, bScalar] = getIndexedValuesFromStorage(scalarRead, [lIndex, rIndex, uIndex, bIndex]);

						const cellScalar = temp(lScalar.add(rScalar).add(uScalar).add(bScalar), 'cellScalar');

						If(cellScalar.equal(0.0), () => {
							Return();
						});

						// Subtract inflow of current cell from inflow of adjacent cells to get the outflow.
						// Current cell inflow represents negative outflow from current cell.
						const currentCellInflowX = temp(velXRead.element(cellIndex), 'currentCellInflowX');
						const currentCellInflowY = temp(velYRead.element(cellIndex), 'currentCellInflowY');
						const currentCellInflow = temp(currentCellInflowX.add(currentCellInflowY), 'currentCellInflow');

						// Adjacent cell inflow represents positive outflow from current cell.
						const adjacentCellInflowX = velXRead.element(rIndex);
						const adjacentCellInflowY = velYRead.element(uIndex);
						const adjacentCellInflow = temp(adjacentCellInflowX.add(adjacentCellInflowY), 'adjacentCellInfow');

						const outflow = temp(adjacentCellInflow.sub(currentCellInflow), 'outflow');
						const negativeOutflow = outflow.sub(outflow.mul(2))
					
						let pressure = negativeOutflow.div(cellScalar);
						pressure.mulAssign(overRelaxationUniform);
					
						pressureWrite.element(cellIndex).addAssign(pressure);

						// Apply scalars to cell velocities
						// Velocity X
						velXWrite.element(cellIndex).subAssign(lScalar.mul(pressure));
						velXWrite.element(rIndex).addAssign(rScalar.mul(pressure));
						// Velocity Y
						velYWrite.element(cellIndex).subAssign(bScalar.mul(pressure));
						velXWrite.element(rIndex).addAssign(rScalar.mul(pressure));

					})().compute(dispatches);

				}

				const getIndexedValuesFromStorage = ( readBuffer, indices ) => {
					const nodes = [];
					for (let i = 0; i < indices.length; i ++) {
						nodes.push(readBuffer.element(indices[i]));
					}
					return nodes;
				}

				const returnColor = (r, g, b) => {
					return vec3(r, g, b);
				}



				computeIntegration = tslFn(() => {

					const velYWriteBuffer = createWriteStorage(velYStartBufferAttribute, 'float');
					const cellIndex = getCellIndexFromInstanceIndexTSL( simCols, bufferCols );
					velYWriteBuffer.element(cellIndex).addAssign(gravityUniform.mul(deltaTimeUniform));

				})().compute(numSimCells);
				

				computeDiv_I0J0 = createDivergenceShader( 0, 0 );
				computeDiv_I0J1 = createDivergenceShader( 0, 1 );
				computeDiv_I1J0 = createDivergenceShader( 1, 0 );
				computeDiv_I1J1 = createDivergenceShader( 1, 1 );

				// Extrapolate velocity of buffer cells from surrounding simulation cells.
				// Effectively a post-processing part of the divergence/outflow/incompressibility step.
				// Shader is a bit of hack, making use of the fact that our grid dimensions are always square.
				computeExtrapolateX = tslFn(() => {
					const velXReadWrite = storage(velXDivergenceBufferAttribute, 'float', 1);

					// Buffer cell to left of first simulation column
					const cellLeftBufferIndex = instanceIndex.mul(bufferCols);
					// Buffer cell to right of last simulation column
					const cellRightBufferIndex = cellLeftBufferIndex.add(bufferCols - 1);

					// Apply horizontal velocity of simulation cells to left and right buffer cells
					const leftBufferVelocity = velXReadWrite.element(cellLeftBufferIndex);
					leftBufferVelocity.assign(velXReadWrite.element(cellLeftBufferIndex.add(1)));

					const rightBufferVelocity = velXReadWrite.element(cellRightBufferIndex);
					rightBufferVelocity.assign(velXReadWrite.element(cellRightBufferIndex.sub(1)));

				})().compute(bufferRows); 

				computeExtrapolateY = tslFn(() => {
					const velYReadWrite = storage(velYDivergenceBufferAttribute, 'float', 1);

					// Buffer cell below first simulation row
					const cellBottomBufferIndex = instanceIndex;
					// Buffer cell above last simulation row
					const cellTopBufferIndex = instanceIndex.add(bufferCols * bufferRows - 1);

					// Apply vertical velocity of simulation cells to top and bottom buffer cells
					const bottomBufferVelocity = velYReadWrite.element(cellBottomBufferIndex);
					bottomBufferVelocity.assign(velYReadWrite.element(cellBottomBufferIndex.add(1)));

					const topBufferVelocity = velYReadWrite.element(cellTopBufferIndex);
					topBufferVelocity.assign(velYReadWrite.element(cellTopBufferIndex.sub(1)));

				})().compute(bufferCols)


				computeAdvection = tslFn(() => {

				})


				const storageFragmentShader = createColorOutputTSL(1.0, 0.0, 0.0);

				const textureFragmentShader = tslFn(() => {

					returnColor(r, g, b);

				});

				camera = new THREE.OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );
				sceneWindTunnel = new THREE.Scene();

				const geometry = new THREE.PlaneGeometry( 2, 2 );

				const simWithStorageQuad = new THREE.Mesh( geometry, new MeshBasicNodeMaterial({
					colorNode: storageFragmentShader(),
				}));
				sceneWindTunnel.add( simWithStorageQuad );

				const simWithTextureQuad = new THREE.Mesh( geometry, new MeshBasicNodeMaterial({
					colorNode: textureFragmentShader(),
				}));
				sceneWindTunnel.add( simWithTextureQuad );
				simWithTextureQuad.visible = false;

				const params = {
					method: 'storageBuffer'
				};

				const gui = new GUI();

				gui.add(params, 'method', computeMethods).onChange(() => {
					console.log(params.method)

					if (params.method === 'storageBuffer') {

						simWithTextureQuad.visible = false;
						simWithStorageQuad.visible = true;

					}

					if (params.method === 'storageTexture') {
						
						simWithStorageQuad.visible = false;
						simWithTextureQuad.visible = true;

					}

				})

				renderer.setAnimationLoop( animate );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function animate() {

				if (currentSceneIndex === 0) {

					renderer.render(sceneDivergencePlayground, camera)

				} else {

					renderer.compute(computeIntegration);

					// Not aware of good mechanism to update uniforms in between compute passes,
					// So for now, we just execute four separate shaders
					for (let i = 0; i < 1; i++) {

						renderer.compute(computeDiv_I0J0);
						renderer.compute(computeDiv_I0J1);
						renderer.compute(computeDiv_I1J0);
						renderer.compute(computeDiv_I1J1);

					} 

					// renderer.compute(computeExtrapolateX)
					// renderer.compute(computeExtrapolateY)
					// renderer.compute(computeAdvection)
					// renderer.compute(computeSmoke)

					renderer.render( sceneWindTunnel, camera );

				}

			}

			init();

		</script>
	</body>
</html>
