<html lang="en">
	<head>
		<title>three.js - WebGPU - Fluid Tunnel</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> WebGPU - Fluid Tunnel
		</div>
		<div id="container">
			<canvas id="c"></canvas>
		
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.module.js",
					"three/addons/": "./jsm/",
					"three/nodes": "./jsm/nodes/Nodes.js"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three';
			// In TSL, unless directly operating on a node, nearly every function you deploy needs to be imported from Nodes.js
			import { vec2, vec3, vec4, sqrt, sign, mix, smoothstep, step, radians, atan2, cos, sin, clamp, length, abs, min, max, float, timerLocal, cond, positionGeometry, varying, varyingProperty, floor, uv, remainder, If, tslFn, storageTexture, expression, MeshBasicNodeMaterial, temp, negate, storage, storageReadOnly, wgslFn, code, instanceIndex, uniform, Return, texture, fract } from 'three/nodes';
			import WebGPU from 'three/addons/capabilities/WebGPU.js';
			import WebGPURenderer from 'three/addons/renderers/webgpu/WebGPURenderer.js';
			import StorageTexture from 'three/addons/renderers/common/StorageTexture.js';
			import StorageBufferAttribute from 'three/addons/renderers/common/StorageBufferAttribute.js';
			import { GUI } from 'three/addons/libs/lil-gui.module.min.js';

			// Define objects shared across scenes
			// Same orthographic camera and WebGPU renderer used across both scenes.
			let camera, renderer, mouse, currentScene, currentSceneInfo, settings;
			// Uniforms
			let uSimCols, uSimRows, uBufferCols, uBufferRows;
			// Scene info
			let sceneDivergenceInfo, sceneWindTunnelInfo;
			let sceneDivergencePlayground, sceneWindTunnel;
			const SCENE_DIVERGENCE_PLAYGROUND = 0;
			const SCENE_WIND_TUNNEL = 1;
			let currentSceneIndex = SCENE_DIVERGENCE_PLAYGROUND;
			const sceneEnum = {

				'Divergence Playground': SCENE_DIVERGENCE_PLAYGROUND,
				'Wind Tunnel': SCENE_WIND_TUNNEL

			}

			// Will the wind tunnel fragment shader pull its velocity from a storage texture or a storage buffer?
			let storageFragmentShader, textureFragmentShader;
			const computeMethods = {
				'Storage Texture': 'storageTexture',
				'Storage Buffer': 'storageBuffer',
			}

			// Scene 0 Specific Constants
			const outflowIndicatorMaxRadius = 0.5;
			const maximumVelocity = 4.0;

			// Define the compute shaders that will perform our per-frame fluid simulation
			// Step 1. Apply gravity to velocity x, y (u, v);
			//let computeIntegration;
			// Step 2. Compute divergence, make velocity of each cell incompressible (used in divergence playground as well)
			//let computeDiv_I0J0, computeDiv_I0J1, computeDiv_I1J0, computeDiv_I1J1;
			// Step 3. Extrapolate velocities of buffer cells from divergence velocities.
			//let computeExtrapolateX, computeExtrapolateY;
			// Step 4. Advect velocities;
			//let computeAdvection;
			// Step 5. Advect smoke;
			//let computeSmoke;

			const canvas = document.getElementById('c');

			// Uniform across all scenes
			let simHeight, cScale, simWidth, domainHeight, domainWidth, res;

			// UTILITY FUNCTIONS
			// Functions designated for use in TSL blocks have TSL appended to their names.

			// Dimension utility functions
			const getSimGridDimensions = (h) => {

				const simCols = Math.floor( domainWidth / h );
				const simRows = Math.floor( domainHeight / h );
				console.log(`simCols: ${simCols}, simRows: ${simRows}`);
				return { simCols, simRows };

			}

			const getBufferGridDimensions = ( simCols, simRows, cellBuffer ) => {

				const buffer = cellBuffer * 2;
				const bufferCols = simCols + buffer;
				const bufferRows = simRows + buffer;
				console.log(`bufferCols: ${bufferCols}, bufferRows: ${bufferRows}`);
				const numBufferCells = bufferCols * bufferRows;
				return {bufferCols, bufferRows, numBufferCells};

			}

			// Indexing utility functions
			const getCellIndexFromInstanceIndex = ( index, simCols, bufferCols ) => {

				const simGridX = index % simCols;
				const simGridY = Math.floor(index / simCols);
				const bufferGridX = simGridX + 1;
				const bufferGridY = simGridY + 1;
				return bufferGridY * bufferCols + bufferGridX;

			}

			const getCellIndexFromInstanceIndexTSL = ( simCols, bufferCols ) => {

				// 2D index of sim grid cell (x, y)
				const simGridCol = temp(instanceIndex.remainder(simCols), 'simGridX');
				const simGridRow = temp(instanceIndex.div(simCols), 'simGridY');
				// 2D index of sim grid cell in buffered grid (x, y)
				const bufferGridCol = temp(simGridCol.add(1), 'bufferGridX');
				const bufferGridRow = temp(simGridRow.add(1), 'bufferGridY');
				// Convert to 1D index into buffered grid for storage buffer access
				return temp(bufferGridCol.add(bufferGridRow.mul(bufferCols)), 'cellIndex');

			}

			const getOffsetCellIndexTSL = ( dispatchesX, offsetX, offsetY ) => {

				// Work in the coordinates of our non-adjacent cells compressed together into a separate grid
				// In a 2d compute execution context, these are analagous with the x and y ids of our threads
				const compactGridCol = temp(instanceIndex.remainder(dispatchesX), 'compactGridX');
				const compactGridRow = temp(instanceIndex.div(dispatchesX), 'compactGridY' );

				// Get location of compact grid cell in sim grid cell space
				const simGridCol = compactGridCol.mul(2).add(offsetX);
				const simGridRow = compactGridRow.mul(2).add(offsetY);

				// Get index of sim grid cell in buffer grid (x, y)
				const bufferGridCol = temp(simGridCol.add(1), 'bufferGridX');
				const bufferGridRow = temp(simGridRow.add(1), 'bufferGridY');

				// Convert to 1D index into buffered grid for storage buffer access
				return temp(
					bufferGridCol.add(bufferGridRow.mul(bufferCols)),
					'cellIndex',
				);

			}

			const getIndexedValuesFromStorageTSL = ( readBuffer, indices ) => {

				const nodes = [];
				for (let i = 0; i < indices.length; i ++) {
					nodes.push(readBuffer.element(indices[i]));
				}
				return nodes;

			}

			// Compute utility functions
			const calculateCellOutflow = (
				velXArray,
				velYArray,
				cellIndex,
				bufferCols,
			) => {

				return (velXArray[cellIndex + 1] + velYArray[cellIndex + bufferCols]) - (velXArray[cellIndex] + velYArray[cellIndex]);

			}
			
			const calculateCellOutflowTSL = (
				velXReadNode,
				velYReadNode,
				cellIndexNode, 
				rIndexNode,
				uIndexNode
			) => {

				// Current cell inflow represents negative outflow from current cell.
				const inflowIntoCell = velXReadNode.element(cellIndexNode).add(velYReadNode.element(cellIndexNode));
				// Adjacent cell inflow represents positive outflow from current cell.
				const outflowFromCell = velXRead.element(rIndex).add(velYRead.element(uIndex));
				// Subtract outflow by inflow
				return outflowFromCell.sub(inflowIntoCell);

			}
			

			const correctCellDivergence = (
				velXArray,
				velYArray,
				cellIndex, 
				bufferCols,
			) => {
				const outflow = calculateCellOutflow(velXArray, velYArray, cellIndex, bufferCols);
					
				let pressure = -outflow / cellScalar.div(cellScalar);
				//pressure.mulAssign(uOverRelaxation);
					
				pressureWrite.element(cellIndex).addAssign(pressure);

				velXArray[cellIndex] -= lScalar * pressure;
				velXArray[cellIndex + 1] += rScalar + pressure;

				velYArray[cellIndex] -= bScalar * pressure;
				velYArray[cellIndex + 1] += uScalar * pressure;

			}

			const calculateDivergenceStepDispatches = (numCols, numRows, offsetX, offsetY) => {
				const dispatchX = Math.floor( (numCols + 1 - offsetX) / 2);
				const dispatchY = Math.floor( (numRows + 1 - offsetY) / 2);
				return { dispatchX, dispatchY };
			}

			const createProjectionComputeShaders = ( velXAttrib, velYAttrib, pressureAttrib, scalarAttrib, sceneInfo ) => {
				// Create shader storage buffers
				const velXStorage = storage(velXAttrib, 'float', sceneInfo.numBufferCells );
				const velYStorage = storage( velYAttrib, 'float', sceneInfo.numBufferCells );
				const pressureStorage = storage( pressureAttrib, 'float', sceneInfo.numBufferCells);
				const scalarStorage = storage( scalarAttrib, 'uint', sceneInfo.numBufferCells );

				const createProjectionShader = ( offsetX, offsetY ) => {
					const {dispatchX, dispatchY} = calculateDivergenceStepDispatches(sceneInfo.simCols, sceneInfo.simRows, offsetX, offsetY);
					const dispatches = dispatchX * dispatchY;

					return tslFn(() => {

						const cellIndex = getOffsetCellIndexTSL( dispatchX, offsetX, offsetY );
					
						// No need for boundary checks since our cellIndex is buffered
						const lIndex = temp(cellIndex.sub(1), 'cellLeftIndex');
						const rIndex = temp(cellIndex.add(1), 'cellRightIndex');
						const uIndex = temp(cellIndex.add(uBufferCols), 'cellAboveIndex');
						const bIndex = temp(cellIndex.sub(uBufferCols), 'cellBelowIndex');

						const [lScalar, rScalar, uScalar, bScalar] = getIndexedValuesFromStorageTSL(scalarStorage, [lIndex, rIndex, uIndex, bIndex]);

						const cellScalar = temp(lScalar.add(rScalar).add(uScalar).add(bScalar), 'cellScalar');

						If(cellScalar.equal(0.0), () => {
							Return();
						});

						const outflow = calculateCellOutflowTSL(velXStorage, velYStorage, cellIndex, rIndex, uIndex);
						const negativeOutflow = negate(outflow);
					
						const newPressure = negativeOutflow.div(cellScalar);
						//pressure.mulAssign(uOverRelaxation);
					
						pressureStorage.element(cellIndex).addAssign(newPressure);

						// Apply scalars to cell velocities
						// Velocity X
						velXStorage.element(cellIndex).subAssign(lScalar.mul(newPressure));
						velXStorage.element(rIndex).addAssign(rScalar.mul(newPressure));
						// Velocity Y
						velYStorage.element(cellIndex).subAssign(bScalar.mul(newPressure));
						velYStorage.element(uIndex).addAssign(uScalar.mul(newPressure));

					})().compute(dispatches);

				}

				// Assign properly alligned divergence shaders to compute projection step
				sceneInfo.computeProjection = [
					createProjectionShader( 0, 0 ), 
					createProjectionShader( 1, 0 ),
					createProjectionShader( 0, 1 ),
					createProjectionShader( 1, 1 )
				];
				
			}

			// Fragment shader utility functions
			const rotateUVTSL = ( pointNode, angleNode ) => {

				const cosAngle = cos( angleNode );
				const sinAngle = sin( angleNode );
				const rotateX = cosAngle.mul( pointNode.x ).add( sinAngle.mul( pointNode.y ) );
				const rotateY = negate( sinAngle ).mul( pointNode.x ).add( cosAngle.mul( pointNode.y ) );
				return vec2( rotateX, rotateY );

			}

			const getBorderTSL = ( uvNode, widthNode ) => {

				const bl = step(vec2(widthNode), uvNode);
				const tr = step(vec2(widthNode), negate(uvNode).add(1.0));
				const isBorder = abs(bl.x.mul(bl.y).mul(tr.x).mul(tr.y).sub(1.0));
				return vec3(isBorder.mul(0.0), isBorder.mul(0.25), isBorder.mul(1.0));

			}

			const sdfCircleTSL = ( pointNode, radiusNode ) => {

				return length(pointNode).sub(radiusNode);

			}

			const sdfBoxTSL = ( uvNode, dimensionsNode ) => {

				const d = abs( uvNode ).sub( dimensionsNode );
				return length( max( d, float(0.0) ) ).add( min( max( d.x, d.y ), 0.0 ) )

			}

			const sdfEquilateralTriangleTSL = ( uvNode, radiusNode, offsetNode ) => {

				const p = uvNode;
				p.addAssign(offsetNode)
				const r = radiusNode;
				const k = sqrt( 3.0 );
				p.x.assign( abs( p.x ).sub( r ) );
				p.y.assign(p.y.add(r.div(k)));
				If(p.x.add(k.mul(p.y)).greaterThan(0.0), () => {

					const x = p.x.sub(k.mul(p.y));
					const y = negate(k).mul(p.x);
					y.subAssign(p.y);
					p.assign(vec2(x, y).div(2.0));

				})

				p.x.subAssign(clamp(p.x, r.mul(-2.0), 0.0));
				return negate(length(p).mul(sign(p.y)));

			}

			const createColorOutputTSL = (r, g, b) => tslFn(() => {

					return vec3(r, g, b);

			})

			const switchScene = (index) => {
				if (index === 0) {
					currentSceneInfo = sceneDivergenceInfo;
					currentScene = sceneDivergencePlayground;
				} else {
					currentSceneInfo = sceneWindTunnelInfo
					currentScene = sceneWindTunnel;
				}

				uSimCols = currentSceneInfo.simCols;
				uSimRows = currentSceneInfo.simRows;
				uBufferCols = currentSceneInfo.bufferCols;
				uBufferRows = currentSceneInfo.bufferRows;

			}

			const setupSceneDivergencePlayground = () => {

				// Calculate proper cell height
				const res = 10;
				const h = domainHeight / res;

				// Get proper buffer grid and simulation grid dimensions
				const { simCols, simRows } = getSimGridDimensions( h );
				const numSimCells = simCols * simRows;
				const { bufferCols, bufferRows, numBufferCells } = getBufferGridDimensions(simCols, simRows, 1);

				// Create scene info template, which gets filled out as we initialize this scene
				sceneDivergenceInfo = {
					simCols: simCols, 
					simRows: simRows, 
					numSimCells: simCols * simRows,
					bufferCols: bufferCols,
					bufferRows: bufferRows,
					numBufferCells: bufferCols * bufferRows,
				}

				// Scene specific uniforms
				const uSelectSimCell = uniform(13);

				// Scene specific Web API events
				canvas.addEventListener('mousemove', (event) => {

					const cellWidth = canvas.clientWidth / simCols;
					const cellHeight = canvas.clientHeight / simRows;
					const cellX = Math.floor(event.clientX / cellWidth);
					const cellY = Math.floor((canvas.clientHeight - event.clientY) / cellHeight);

					const cellBufferX = cellX + 1;
					const cellBufferY = cellY + 1;
					const cellIndex = cellBufferX + cellBufferY * bufferCols;
					uSelectSimCell.value = cellIndex

				})

				// Create buffers for compute calculations
				const velXBufferAttribute = new StorageBufferAttribute( numBufferCells, 1 );
				const velYBufferAttribute = new StorageBufferAttribute( numBufferCells, 1 );
				const outflowBufferAttribute = new StorageBufferAttribute( numBufferCells, 1 );
				const scalarBufferAttribute = new StorageBufferAttribute( numBufferCells, 1 );

				// Make all cells obstacle
				scalarBufferAttribute.array.fill(0);
				
				// Randomize velocity values
				for (let i = 0; i < numSimCells; i++) {

					const cellIndex = getCellIndexFromInstanceIndex( i, simCols, bufferCols );
					velXBufferAttribute.array[cellIndex] = 2;//Math.random() * (maximumVelocity * 2) - maximumVelocity;
					velYBufferAttribute.array[cellIndex] = Math.random() * (maximumVelocity * 2) - maximumVelocity;
					// Indicate that cell is sim cell and not obstacle cell.
					scalarBufferAttribute.array[cellIndex] = 1;

				}

				// Calculate current divergence/outflow based on randomized velocity values
				for (let i = 0; i < numSimCells; i++) {

					const cellIndex = getCellIndexFromInstanceIndex( i, simCols, bufferCols );
					outflowBufferAttribute.array[cellIndex] = calculateCellOutflow( velXBufferAttribute.array, velYBufferAttribute.array, cellIndex, bufferCols );

				}

				// Create Compute Shaders
				createProjectionComputeShaders(velXBufferAttribute, velYBufferAttribute, pressureBufferAttribute, scalarBufferAttribute)
				
				sceneDivergencePlayground = new THREE.Scene();

				const quadWidth = 2 / simCols;
				const quadHeight = 2 / simRows;

				//const geometry = new THREE.PlaneGeometry(quadWidth, quadHeight);
				const geometry = new THREE.PlaneGeometry(2, 2);

				const textureLoader = new THREE.TextureLoader()
				const waterTexture = textureLoader.load('textures/water/WaterTexture.png');
				waterTexture.wrapS = THREE.RepeatWrapping;
				waterTexture.wrapT = THREE.RepeatWrapping;
				
				// Create color constants
				const white = vec4(1.0, 1.0, 1.0, 1.0);
				const green = vec4(0.0, 1.0, 0.0, 1.0);
				const black = vec4(0.0, 0.0, 0.0, 1.0);
				
				const divergenceFragmentNode = tslFn(() => {

					const velXRead = storageReadOnly( velXBufferAttribute, 'float', numBufferCells );
					const velYRead = storageReadOnly( velYBufferAttribute, 'float', numBufferCells );
					const outflowRead = storageReadOnly( outflowBufferAttribute, 'float', numBufferCells );
					const uvGrid = temp( uv().mul( vec2( uSimCols, uSimRows ) ), 'uvGrid' );
					// 2D Coordinate in Simulation Grid
					const simGrid2DIndex = temp( floor( uvGrid ), 'simGrid2DIndex' );
					// 2D Coordinate in Buffer Grid
					const bufferGrid2DIndex = temp( simGrid2DIndex.add( 1 ), 'bufferGrid2DIndex' );
					// 1D Coordinate in Buffer Grid
					const cellIndex = temp( bufferGrid2DIndex.x.add( bufferGrid2DIndex.y.mul( bufferCols ) ), 'cellIndex' );

					// Note: Calculate divergence value with actual value from buffers
					// Negate velX and velY to move cell and rotate arrow in proper direction (+x goes right +y goes up)
					const velX = velXRead.element( cellIndex );
					const velY = velYRead.element( cellIndex );
					const outflow = outflowRead.element( cellIndex );

					const samplePoint = temp(
						vec2(
							fract(uvGrid.x.add( timerLocal().mul( negate(velX) ) )),
							fract(uvGrid.y.add( timerLocal().mul( negate(velY) ) ))
						),
						'samplePoint'
					);

					// Get 0 to 1 uv coordinates of each cell
					const uvCell = fract(uvGrid);
					// Get -1 to 1 uv coordinates of each cell
					const uvCellNDC = uvCell.mul(2.0).sub(1.0);
					// Add angle in radians between x-axis and velocity vector
					const angle = atan2(negate(velY), negate(velX))
					// Set base rotation to allign with x axis
					angle.subAssign(radians(-90.0))
					// Rotate uv coordinates by angle determined by velocity. 
					const uvCellNDCRotated = rotateUVTSL(uvCellNDC, angle);
					// For some reason uvCellNDCRotated only works for box when it's written inline
					const boxSDF = sdfBoxTSL(rotateUVTSL(uvCell.mul(2.0).sub(1.0), angle), vec2(0.05, 0.6));
					const triangleSDF = sdfEquilateralTriangleTSL(uvCellNDCRotated, float(0.2), vec2(0.0, -0.5));
					// Combine box and triangle into arrow
					const arrowSDF = min(boxSDF, triangleSDF);
					const arrowCheck = temp(arrowSDF.lessThan(0.0), 'check');

					// Apply circle SDF with radius defined by the outflow
					// Put outflow in range of -1 to 1. The maximum outflow is maxVelocityX + maxVelocityY. The minimumn outflow is the inverse of the maximumn (i.e everything flowing in or everything flowing out)
					const normalizedOutflow = temp(outflow.div(maximumVelocity * 2), 'normalizedOutflow');
					const circleRadius = float(outflowIndicatorMaxRadius).mul(abs(normalizedOutflow));

					const circleSDF = temp(min(sdfCircleTSL(uvCellNDC, circleRadius), 0.01), 'circleSDF');
					const circleCheck = temp(circleSDF.lessThan(0.0), 'circleCheck');
					const textureColor = temp(
						texture(waterTexture, samplePoint),
						'textureColor'
					);

					// When outflow is positive, show green, else show black.
					const circleColor = temp( normalizedOutflow.lessThan(0.0).cond(black, green), 'circleColor');

					// Apply outflow indicator to color (green for outflow/production, black for inflow/destruction)
					textureColor.x.assign(mix(textureColor.x, circleColor.x, circleCheck));
					textureColor.y.assign(mix(textureColor.y, circleColor.y, circleCheck));
					textureColor.z.assign(mix(textureColor.z, circleColor.z, circleCheck));

					// Apply Arrow SDF to color
					textureColor.addAssign(white.mul(arrowCheck));

					// Apply Border on highlight 
					const isCellHighlighted = temp(cellIndex.equal(uSelectSimCell), 'isCellHighlighted');
					const borderColor = getBorderTSL(uvCell, 0.03).mul(isCellHighlighted);
					const finalColor = mix(textureColor.rgb, borderColor, max(borderColor.r, max(borderColor.g, borderColor.b)));
						
					return finalColor;
				})

				const nodeMaterial = new MeshBasicNodeMaterial();
				nodeMaterial.colorNode = divergenceFragmentNode();
				const mesh = new THREE.Mesh(geometry, nodeMaterial);

				sceneDivergencePlayground.add(mesh)

			}

			const setupSceneWindTunnel = () => {

				// Set resolution and determine grid cell height based on resolution
				const res = 100;
				const h = domainHeight / res;

				// Get wind tunnel buffer grid and simulation grid dimensions
				const {simCols, simRows} = getSimGridDimensions(h);
				const numSimCells = simCols * simRows;
				const {bufferCols, bufferRows, numBufferCells} = getBufferGridDimensions(simCols, simRows, 1);

				sceneWindTunnelInfo = {
					simCols: simCols,
					simRows: simRows,
					numSimCells: numSimCells,
					bufferCols: bufferCols,
					bufferRows: bufferRows,
					numBufferCells: numBufferCells
				}

				// Create buffers and uniforms specific to wind tunnel simulation
				const velXBufferAttribute = new StorageBufferAttribute( numBufferCells, 1 );
				const velYBufferAttribute = new StorageBufferAttribute( numBufferCells, 1 );
				const pressureBufferAttribute = new StorageBufferAttribute( numBufferCells, 1 );
				const dBufferAttribute = new StorageBufferAttribute( numBufferCells, 1 );
				const scalarBufferAttribute = new StorageBufferAttribute( numBufferCells, 1 );

				const uOverRelaxation = uniform(1.9);
				const uCP = uniform(1000)
				const uDensity = uniform(1000);
				const uGravity = uniform(-9.81);

				createProjectionComputeShaders( velXBufferAttribute, velYBufferAttribute, pressureBufferAttribute, scalarBufferAttribute, sceneWindTunnelInfo );

				const computeIntegrationShader = tslFn(() => {

					const velYWriteBuffer = storage(velYStartBufferAttribute, 'float', numBufferCells);
					const cellIndex = getCellIndexFromInstanceIndexTSL( simCols, bufferCols );
					velYWriteBuffer.element(cellIndex).addAssign(gravityUniform.mul(deltaTimeUniform));

				})().compute(numSimCells);

				// Extrapolate velocity of buffer cells from surrounding simulation cells.
				// Effectively a post-processing part of the divergence/outflow/incompressibility step.
				// Shader is a bit of hack, making use of the fact that our grid dimensions are always square.
				const computeExtrapolateXShader = tslFn(() => {
					const velXReadWrite = storage(velXDivergenceBufferAttribute, 'float', 1);

					// Buffer cell to left of first simulation column
					const cellLeftBufferIndex = instanceIndex.mul(bufferCols);
					// Buffer cell to right of last simulation column
					const cellRightBufferIndex = cellLeftBufferIndex.add(bufferCols - 1);

					// Apply horizontal velocity of simulation cells to left and right buffer cells
					const leftBufferVelocity = velXReadWrite.element(cellLeftBufferIndex);
					leftBufferVelocity.assign(velXReadWrite.element(cellLeftBufferIndex.add(1)));

					const rightBufferVelocity = velXReadWrite.element(cellRightBufferIndex);
					rightBufferVelocity.assign(velXReadWrite.element(cellRightBufferIndex.sub(1)));

				})().compute(bufferRows); 

				const computeExtrapolateYShader = tslFn(() => {
					const velYReadWrite = storage(velYDivergenceBufferAttribute, 'float', 1);

					// Buffer cell below first simulation row
					const cellBottomBufferIndex = instanceIndex;
					// Buffer cell above last simulation row
					const cellTopBufferIndex = instanceIndex.add(bufferCols * bufferRows - 1);

					// Apply vertical velocity of simulation cells to top and bottom buffer cells
					const bottomBufferVelocity = velYReadWrite.element(cellBottomBufferIndex);
					bottomBufferVelocity.assign(velYReadWrite.element(cellBottomBufferIndex.add(1)));

					const topBufferVelocity = velYReadWrite.element(cellTopBufferIndex);
					topBufferVelocity.assign(velYReadWrite.element(cellTopBufferIndex.sub(1)));

				})().compute(bufferCols)


				const computeAdvectionShader = tslFn(() => {

				}).compute(numBufferCells);

				const returnColor = (r, g, b) => {
					return vec3(r, g, b);
				}


				const storageFragmentShader = createColorOutputTSL(1.0, 0.0, 0.0);

				const textureFragmentShader = tslFn(() => {

					returnColor(r, g, b);

				});

				sceneWindTunnel = new THREE.Scene();

				const geometry = new THREE.PlaneGeometry( 2, 2 );

				const simWithStorageQuad = new THREE.Mesh( geometry, new MeshBasicNodeMaterial({
					colorNode: storageFragmentShader(),
				}));
				sceneWindTunnel.add( simWithStorageQuad );

				const simWithTextureQuad = new THREE.Mesh( geometry, new MeshBasicNodeMaterial({
					colorNode: textureFragmentShader(),
				}));
				sceneWindTunnel.add( simWithTextureQuad );
				simWithTextureQuad.visible = false;


				sceneWindTunnelInfo = {
					simCols: simCols,
					simRows: simRows,
					bufferCols: bufferCols,
					bufferRows: bufferRows,
					computeIntegration: computeIntegrationShader,
					computeProjection: [computeDiv_I0J0, computeDiv_I0J1, computeDiv_I1J0, computeDiv_I1J1],
					computeExtrapolateX: computeExtrapolateXShader,
					computeExtrapolateY: computeExtrapolateYShader,
					computeAdvection: computeAdvectionShader,

				}

			}

			function init() {

				if ( WebGPU.isAvailable() === false ) {

					document.body.appendChild( WebGPU.getErrorMessage() );

					throw new Error( 'No WebGPU support' );

				}
				
				// Create renderer
				renderer = new WebGPURenderer( { antialias: true, canvas: canvas} );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				document.body.appendChild( renderer.domElement );
				window.addEventListener( 'resize', onWindowResize );

				// For now try to use same camera for each scene
				camera = new THREE.OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );

				// Create simulation height
				simHeight = 1.0
				cScale = canvas.height / simHeight;
				simWidth = canvas.width / cScale;
				domainHeight = 1.0;
				domainWidth = domainHeight / simHeight * simWidth;

				uSimCols = uniform(0);
				uSimRows = uniform(0);
				uBufferCols = uniform(0);
				uBufferRows = uniform(0);

				setupSceneDivergencePlayground();
				setupSceneWindTunnel();
				
				switchScene(currentSceneIndex);

				settings = {
					'Projection Iterations': 100,
					'Run Projection': 2,
					'Current Scene': 'Divergence Playground'
				};

				const gui = new GUI();

				gui.add(settings, 'Projection Iterations', 50, 300).step(50);

				renderer.setAnimationLoop( animate );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function animate() {

				//renderer.compute(currentSceneInfo.integration);

				if (currentSceneInfo.computeProjection) {

					for (let i = 0; i < settings[ 'Projection Iterations' ]; i++) {
						for ( let j = 0; j < currentScene.computeProjection.length; j++ ) {
							renderer.compute(currentSceneInfo.computeProjection[i]);
						}
					}

				}

				if (currentSceneInfo.computeExtrapolateX) {

					renderer.compute(currentSceneInfo.computeExtrapolateX)
					
				}

				if ( currentSceneInfo.computeExtrapolateY ) {

					renderer.compute( currentSceneInfo.computeExtrapolateY );

				}

				if ( currentSceneInfo.computeE)

				/* for (let i = 0; i < settings[ 'Projection Iterations' ]; i++) {

					renderer.compute(currentSceneInfo.projectionI0J0);
					renderer.compute(currentSceneInfo.projectionI0J1);
					renderer.compute(currentSceneInfo.projectionI1J0);
					renderer.compute(currentSceneInfo.projectionI1J1);

				} */

				//renderer.compute(currentSceneInfo.extrapolateX)
				//renderer.compute(currentSceneInfo.extrapolateY)
				//renderer.compute(currentSceneInfo.advectFluid)
				//renderer.compute(currentSceneInfo.advectSmoke)

				renderer.render(currentScene, camera);

			}

			init();

		</script>
	</body>
</html>
