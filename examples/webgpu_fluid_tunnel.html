<html lang="en">
	<head>
		<title>three.js - WebGPU - Fluid Tunnel</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> WebGPU - Fluid Tunnel
		</div>
		<div id="container">
			<canvas id="c"></canvas>
		
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.module.js",
					"three/addons/": "./jsm/",
					"three/nodes": "./jsm/nodes/Nodes.js"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three';
			// In TSL, unless directly operating on a node, nearly every function you deploy needs to be imported from Nodes.js
			import { vec2, vec3, vec4, sqrt, sign, mix, smoothstep, step, radians, atan2, cos, sin, clamp, length, abs, min, max, float, timerLocal, cond, positionGeometry, varying, varyingProperty, floor, uv, remainder, If, tslFn, storageTexture, expression, MeshBasicNodeMaterial, temp, negate, storage, storageReadOnly, wgslFn, code, instanceIndex, uniform, Return, texture, fract } from 'three/nodes';
			import WebGPU from 'three/addons/capabilities/WebGPU.js';
			import WebGPURenderer from 'three/addons/renderers/webgpu/WebGPURenderer.js';
			import StorageTexture from 'three/addons/renderers/common/StorageTexture.js';
			import StorageBufferAttribute from 'three/addons/renderers/common/StorageBufferAttribute.js';
			import { GUI } from 'three/addons/libs/lil-gui.module.min.js';

			// Define objects shared across scenes
			// Same orthographic camera and WebGPU renderer used across both scenes.
			let camera, renderer, mouse, currentScene, infoCurrentScene, settings;

			// Global uniforms
			let uSimCols, uSimRows, uBufferCols, uBufferRows;

			// Scene info
			let infoDivergencePlayground, infoWindTunnel;
			let sceneDivergencePlayground, sceneWindTunnel;
			const SCENE_DIVERGENCE_PLAYGROUND = 0;
			const SCENE_WIND_TUNNEL = 1;
			let currentSceneIndex = SCENE_DIVERGENCE_PLAYGROUND;
			const sceneEnum = {
				'Divergence Playground': SCENE_DIVERGENCE_PLAYGROUND,
				'Wind Tunnel': SCENE_WIND_TUNNEL
			}

			const canvas = document.getElementById('c');

			// Uniform across all scenes
			let simHeight, cScale, simWidth, domainHeight, domainWidth, res;

			// UTILITY FUNCTIONS
			// Functions designated for use in TSL blocks have TSL appended to their names.
			// In a TSL utility function, node arguments are appended with 'Node'

			// Dimension utility functions
			const getSimGridDimensions = ( h ) => {

				const simCols = Math.floor( domainWidth / h );
				const simRows = Math.floor( domainHeight / h );
				console.log(`simCols: ${simCols}, simRows: ${simRows}`);
				return { simCols, simRows };

			}

			const getBufferGridDimensions = ( simCols, simRows, cellBuffer ) => {
				
				// Buffered grid places new row and column on each relevant side
				const buffer = cellBuffer * 2;
				// Sim grid colums + buffer column left + buffer column right
				const bufferCols = simCols + buffer;
				// Sim grid rows + buffer row top + buffer row bottom
				const bufferRows = simRows + buffer;
				console.log( `bufferCols: ${bufferCols}, bufferRows: ${bufferRows}` );
				return { bufferCols, bufferRows };

			}

			// Indexing utility functions

			// Convert a 1 dimensional cell index on the simulation grid to a 1 dimensional cell index on the buffer grid
			const getBufferCellIndexFromSimIndexTSL = ( simColsNode, bufferColsNode ) => {

				// 2D index of sim grid cell (x, y)
				const simGridCol = temp( instanceIndex.remainder( simColsNode ), 'simGridX');
				const simGridRow = temp( instanceIndex.div( simColsNode ), 'simGridY');
				// 2D index of sim grid cell in buffered grid (x, y)
				const bufferGridCol = temp( simGridCol.add( 1 ), 'bufferGridX');
				const bufferGridRow = temp( simGridRow.add( 1 ), 'bufferGridY');
				// Convert to 1D index into buffered grid for storage buffer access
				return temp( bufferGridCol.add( bufferGridRow.mul( bufferColsNode )), 'cellIndex' );

			}

			const getBufferCellIndexFromSimIndex = ( index, simCols, bufferCols ) => {

				const simGridX = index % simCols;
				const simGridY = Math.floor( index / simCols );
				const bufferGridX = simGridX + 1;
				const bufferGridY = simGridY + 1;
				return bufferGridY * bufferCols + bufferGridX;

			}

			const getOffsetCellIndexTSL = ( dispatchesX, offsetX, offsetY ) => {

				// Work in the coordinates of our non-adjacent cells compressed together into a separate grid
				// In a 2d compute execution context, these are analagous with the x and y ids of our threads
				const compactGridCol = temp( instanceIndex.remainder( dispatchesX ), 'compactGridX' );
				const compactGridRow = temp( instanceIndex.div( dispatchesX ), 'compactGridY' );

				// Get location of compact grid cell in sim grid cell space
				const simGridCol = compactGridCol.mul( 2 ).add( offsetX );
				const simGridRow = compactGridRow.mul( 2 ).add( offsetY );

				// Get index of sim grid cell in buffer grid (x, y)
				const bufferGridCol = temp(simGridCol.add( 1 ), 'bufferGridX');
				const bufferGridRow = temp(simGridRow.add( 1 ), 'bufferGridY');

				// Convert to 1D index into buffered grid for storage buffer access
				return temp( bufferGridCol.add( bufferGridRow.mul( uBufferCols ) ), 'cellIndex' );

			}

			const getIndexedValuesFromStorageTSL = ( readBuffer, indices ) => {

				const nodes = [];
				for ( let i = 0; i < indices.length; i ++) {

					nodes.push( readBuffer.element( indices[i] ) );

				}

				return nodes;

			}

			// Compute utility functions
			const calculateCellOutflow = ( velXArray, velYArray, cellIndex, bufferCols ) => {

				return ( velXArray[ cellIndex + 1 ] + velYArray[ cellIndex + bufferCols ] ) - (velXArray[ cellIndex ] + velYArray[ cellIndex ] );

			}
			
			const calculateCellOutflowTSL = ( velXReadNode, velYReadNode, cellIndexNode, rIndexNode, uIndexNode ) => {

				// Current cell inflow represents negative outflow from current cell.
				const inflowIntoCell = velXReadNode.element( cellIndexNode ).add( velYReadNode.element( cellIndexNode ) );
				// Adjacent cell inflow represents positive outflow from current cell.
				const outflowFromCell = velXReadNode.element( rIndexNode ).add( velYReadNode.element( uIndexNode ) );
				// Subtract outflow by inflow
				return outflowFromCell.sub( inflowIntoCell );

			}
			
			// TODO JS + TSL Version
			const correctCellDivergence = ( velXArray, velYArray, scalarArray, pressureArray, cellIndex, bufferCols ) => {
				// Calculate the cell's outflow
				const outflow = calculateCellOutflowTSL( velXArray, velYArray, cellIndex, bufferCols );

				const lScalar = scalarArray[ cellIndex - 1 ];
				const rScalar = scalarArray[ cellIndex + 1 ];
				const dScalar = scalarArray[ cellIndex - bufferCols ];
				const uScalar = scalarArray[ cellIndex + bufferCols ];
				const cellScalar = lScalar + rScalar + dScalar + uScalar;
				
				if (cellScalar === 0) {
					return;
				}
6
				let pressure = -outflow / cellScalar;

				pressureArray[cellIndex] += pressure;

				velXArray[ cellIndex ] -= lScalar * pressure;
				velXArray[ cellIndex + 1 ] += rScalar + pressure;

				velYArray[ cellIndex ] -= dScalar * pressure;
				velYArray[ cellIndex + 1 ] += uScalar * pressure;

			}

			const correctCellDivergenceTSL = ( velXNode, velYNode, scalarNode, pressureNode, cellIndexNode ) => {

				const lIndex = temp(cellIndexNode.sub(1), 'cellLeftIndex');
				const rIndex = temp(cellIndexNode.add(1), 'cellRightIndex');
				const uIndex = temp(cellIndexNode.add(uBufferCols), 'cellAboveIndex');
				const dIndex = temp(cellIndexNode.sub(uBufferCols), 'cellBelowIndex');
				const [lScalar, rScalar, uScalar, dScalar] = getIndexedValuesFromStorageTSL( scalarNode, [ lIndex, rIndex, uIndex, dIndex ]	 );
				const cellScalar = temp(lScalar.add(rScalar).add(uScalar).add(dScalar), 'cellScalar');

				If( cellScalar.equal( 0.0 ), () => {
					Return();
				}	);

				const outflow = calculateCellOutflowTSL(velXNode, velYNode, cellIndexNode, rIndex, uIndex);
				const negativeOutflow = negate(outflow);

				const newPressure = negativeOutflow.div(cellScalar);
				//pressure.mulAssign(uOverRelaxation);

				pressureNode.element(cellIndexNode).addAssign(newPressure);
				// Apply scalars to cell velocities
				// Velocity X
				velXNode.element(cellIndexNode).subAssign(lScalar.mul(newPressure));
				velXNode.element(rIndex).addAssign(rScalar.mul(newPressure));
				// Velocity Y
				velYNode.element(cellIndexNode).subAssign(dScalar.mul(newPressure));
				velYNode.element(uIndex).addAssign(uScalar.mul(newPressure));

			}

			const calculateDivergenceStepDispatches = ( numCols, numRows, offsetX, offsetY ) => {
				const dispatchX = Math.floor( (numCols + 1 - offsetX) / 2);
				const dispatchY = Math.floor( (numRows + 1 - offsetY) / 2);
				return { dispatchX, dispatchY };
			}

			const createProjectionComputeShaders = ( velXAttrib, velYAttrib, pressureAttrib, scalarAttrib, sceneInfo ) => {
				// Create shader storage buffers
				const velXStorage = storage( velXAttrib, 'float', sceneInfo.numBufferCells );
				const velYStorage = storage( velYAttrib, 'float', sceneInfo.numBufferCells );
				const pressureStorage = storage( pressureAttrib, 'float', sceneInfo.numBufferCells );
				const scalarStorage = storage( scalarAttrib, 'uint', sceneInfo.numBufferCells );

				const createProjectionShader = ( offsetX, offsetY ) => {
					const {dispatchX, dispatchY} = calculateDivergenceStepDispatches(sceneInfo.simCols, sceneInfo.simRows, offsetX, offsetY);
					const dispatches = dispatchX * dispatchY;

					return tslFn(() => {

						const cellIndex = getOffsetCellIndexTSL( dispatchX, offsetX, offsetY );
					
						// No need for boundary checks since our cellIndex is buffered
						const lIndex = temp(cellIndex.sub(1), 'cellLeftIndex');
						const rIndex = temp(cellIndex.add(1), 'cellRightIndex');
						const uIndex = temp(cellIndex.add(uBufferCols), 'cellAboveIndex');
						const dIndex = temp(cellIndex.sub(uBufferCols), 'cellBelowIndex');

						const [lScalar, rScalar, uScalar, dScalar] = getIndexedValuesFromStorageTSL(scalarStorage, [lIndex, rIndex, uIndex, dIndex]);

						const cellScalar = lScalar.add(rScalar).add(uScalar).add(dScalar);

						If( cellScalar.equal( 0.0 ), () => {
							Return();
						});

						const outflow = calculateCellOutflowTSL(velXStorage, velYStorage, cellIndex, rIndex, uIndex);
						const negativeOutflow = negate(outflow);
					
						const newPressure = negativeOutflow.div(float(cellScalar));
						//pressure.mulAssign(uOverRelaxation);
					
						pressureStorage.element(cellIndex).addAssign(newPressure);

						// Apply scalars to cell velocities
						// Velocity X
						velXStorage.element(cellIndex).subAssign(float(lScalar).mul(newPressure));
						velXStorage.element(rIndex).addAssign(float(rScalar).mul(newPressure));
						// Velocity Y
						velYStorage.element(cellIndex).subAssign(float(dScalar).mul(newPressure));
						velYStorage.element(uIndex).addAssign(float(uScalar).mul(newPressure));

					})().compute(dispatches);

				}

				// Assign properly alligned divergence shaders to compute projection step
				sceneInfo.computeProjection = [
					createProjectionShader( 0, 0 ), 
					createProjectionShader( 1, 0 ),
					createProjectionShader( 0, 1 ),
					createProjectionShader( 1, 1 )
				];

				console.log(sceneInfo.computeProjection)
				
			}

			// Fragment shader utility functions
			const rotateUVTSL = ( pointNode, angleNode ) => {

				const cosAngle = cos( angleNode );
				const sinAngle = sin( angleNode );
				const rotateX = cosAngle.mul( pointNode.x ).add( sinAngle.mul( pointNode.y ) );
				const rotateY = negate( sinAngle ).mul( pointNode.x ).add( cosAngle.mul( pointNode.y ) );
				return vec2( rotateX, rotateY );

			}

			const getBorderTSL = ( uvNode, widthNode ) => {

				const bl = step(vec2(widthNode), uvNode);
				const tr = step(vec2(widthNode), negate(uvNode).add(1.0));
				const isBorder = abs(bl.x.mul(bl.y).mul(tr.x).mul(tr.y).sub(1.0));
				return vec3(isBorder.mul(0.0), isBorder.mul(0.25), isBorder.mul(1.0));

			}

			const sdfCircleTSL = ( pointNode, radiusNode ) => {

				return length(pointNode).sub(radiusNode);

			}

			const sdfBoxTSL = ( uvNode, dimensionsNode ) => {

				const d = abs( uvNode ).sub( dimensionsNode );
				return length( max( d, float(0.0) ) ).add( min( max( d.x, d.y ), 0.0 ) )

			}

			const sdfEquilateralTriangleTSL = ( uvNode, radiusNode, offsetNode ) => {

				const p = uvNode;
				p.addAssign(offsetNode)
				const r = radiusNode;
				const k = sqrt( 3.0 );
				p.x.assign( abs( p.x ).sub( r ) );
				p.y.assign(p.y.add(r.div(k)));
				If(p.x.add(k.mul(p.y)).greaterThan(0.0), () => {

					const x = p.x.sub(k.mul(p.y));
					const y = negate(k).mul(p.x);
					y.subAssign(p.y);
					p.assign(vec2(x, y).div(2.0));

				})

				p.x.subAssign(clamp(p.x, r.mul(-2.0), 0.0));
				return negate(length(p).mul(sign(p.y)));

			}

			const createColorOutputTSL = (r, g, b) => tslFn(() => {

					return vec3(r, g, b);

			});

			// Scene setup utils

			const switchScene = (index) => {

				if (index === SCENE_DIVERGENCE_PLAYGROUND) {

					infoCurrentScene = infoDivergencePlayground;
					currentScene = sceneDivergencePlayground;

				} else {

					infoCurrentScene = infoWindTunnel
					currentScene = sceneWindTunnel;

				}

				// Reassign global uniforms based on current scene
				uSimCols.value = infoCurrentScene.simCols;
				uSimRows.value = infoCurrentScene.simRows;
				uBufferCols.value = infoCurrentScene.bufferCols;
				uBufferRows.value = infoCurrentScene.bufferRows;

			}

			const setupSceneDivergencePlayground = () => {
				// Constants specific to divergence playground
				const outflowIndicatorMaxRadius = 0.5;
				const maximumVelocity = 4.0;

				// Calculate proper cell height
				const res = 10;
				const h = domainHeight / res;

				// Get proper buffer grid and simulation grid dimensions
				const { simCols, simRows } = getSimGridDimensions( h );
				const { bufferCols, bufferRows } = getBufferGridDimensions(simCols, simRows, 1);

				// Create scene info template, which gets filled out as we initialize this scene
				infoDivergencePlayground = {
					simCols: simCols, 
					simRows: simRows, 
					numSimCells: simCols * simRows,
					bufferCols: bufferCols,
					bufferRows: bufferRows,
					numBufferCells: bufferCols * bufferRows
				}

				// Scene specific uniforms
				const uSelectSimCell = uniform(13);

				// Scene specific Web API events
				canvas.addEventListener('mousemove', (event) => {

					const cellWidth = canvas.clientWidth / simCols;
					const cellHeight = canvas.clientHeight / simRows;
					const cellX = Math.floor(event.clientX / cellWidth);
					const cellY = Math.floor((canvas.clientHeight - event.clientY) / cellHeight);

					const cellBufferX = cellX + 1;
					const cellBufferY = cellY + 1;
					const cellIndex = cellBufferX + cellBufferY * bufferCols;
					uSelectSimCell.value = cellIndex

				})
				
				const createBufferAttribute = () => new StorageBufferAttribute( infoDivergencePlayground.numBufferCells, 1 );

				// Create buffers for compute calculations
				const velXBufferAttribute = createBufferAttribute();
				const velYBufferAttribute = createBufferAttribute()
				const pressureBufferAttribute = createBufferAttribute();
				const scalarBufferAttribute = createBufferAttribute();

				const correctSingleCellDivergence = tslFn(() => {
					const velXReadWrite = storage( velXBufferAttribute, 'float', infoDivergencePlayground.numBufferCells);
					const velYReadWrite = storage( velYBufferAttribute, 'float', infoDivergencePlayground.numBufferCells);
					const scalarReadWrite = storage( scalarBufferAttribute, 'uint', infoDivergencePlayground.numBufferCells );
					const pressureReadWrite = storage( pressureBufferAttribute, 'float', infoDivergencePlayground.numBufferCells );

					const lIndex = uSelectSimCell.sub(1);
					const rIndex = uSelectSimCell.add(1);
					const uIndex = uSelectSimCell.add(uBufferCols);
					const dIndex = uSelectSimCell.sub(uBufferCols);
					const [lScalar, rScalar, uScalar, dScalar] = getIndexedValuesFromStorageTSL( scalarReadWrite, [ lIndex, rIndex, uIndex, dIndex ]	 );
					const cellScalar = lScalar.add(rScalar).add(uScalar).add(dScalar);

					If( cellScalar.equal( 0.0 ), () => {
						Return();
					}	);

					const outflow = calculateCellOutflowTSL(velXReadWrite, velYReadWrite, uSelectSimCell, rIndex, uIndex);
					const negativeOutflow = negate(outflow);

					const newPressure = negativeOutflow.div(cellScalar);
					//pressure.mulAssign(uOverRelaxation);

					pressureReadWrite.element(uSelectSimCell).addAssign(newPressure);
					// Apply scalars to cell velocities
					// Correct velocity of current cell
					const velX = velXReadWrite.element(uSelectSimCell);
					const velY = velYReadWrite.element(uSelectSimCell);
					const newVelocityX = velX.sub(float(lScalar).mul(newPressure));
					const newVelocityY = velY.sub(float(dScalar).mul(newPressure));

					velX.assign(newVelocityX);
					velY.assign(newVelocityY);
					//velXReadWrite.element(rIndex).addAssign(rScalar.mul(newPressure));
					// Velocity Y
					//velYReadWrite.element(uSelectSimCell).subAssign(dScalar.mul(newPressure));
					//velYReadWrite.element(uIndex).addAssign(uScalar.mul(newPressure));


					//correctCellDivergenceTSL( velXReadWrite, velYReadWrite, scalarReadWrite, pressureReadWrite, uSelectSimCell);
				})().compute(1);

				canvas.addEventListener('click', (event) => {
					renderer.compute(correctSingleCellDivergence);
				});

				// Make all cells obstacle
				scalarBufferAttribute.array.fill(0);
				
				// Randomize velocity values
				for (let i = 0; i < infoDivergencePlayground.numSimCells; i++) {

					const cellIndex = getBufferCellIndexFromSimIndex( i, simCols, bufferCols );
					velXBufferAttribute.array[cellIndex] = Math.floor(Math.random() * (maximumVelocity * 2) - maximumVelocity);
					velYBufferAttribute.array[cellIndex] = Math.floor(Math.random() * (maximumVelocity * 2) - maximumVelocity);
					// Indicate that cell is sim cell and not obstacle cell.
					scalarBufferAttribute.array[cellIndex] = 1;

				}

				console.log(velXBufferAttribute);
				console.log(velYBufferAttribute);

				// Create Compute Shaders
				createProjectionComputeShaders(velXBufferAttribute, velYBufferAttribute, pressureBufferAttribute, scalarBufferAttribute, infoDivergencePlayground);
				
				sceneDivergencePlayground = new THREE.Scene();

				const quadWidth = 2 / simCols;
				const quadHeight = 2 / simRows;

				//const geometry = new THREE.PlaneGeometry(quadWidth, quadHeight);
				const geometry = new THREE.PlaneGeometry(2, 2);

				const textureLoader = new THREE.TextureLoader()
				const waterTexture = textureLoader.load('textures/water/WaterTexture.png');
				waterTexture.wrapS = THREE.RepeatWrapping;
				waterTexture.wrapT = THREE.RepeatWrapping;
				
				// Create color constants
				const white = vec4(1.0, 1.0, 1.0, 1.0);
				const green = vec4(0.0, 1.0, 0.0, 1.0);
				const black = vec4(0.0, 0.0, 0.0, 1.0);
				
				const divergenceFragmentNode = tslFn(() => {
					const velXRead = storageReadOnly( velXBufferAttribute, 'float', infoDivergencePlayground.numBufferCells);
					const velYRead = storageReadOnly( velYBufferAttribute, 'float', infoDivergencePlayground.numBufferCells );

					const uvGrid = temp( uv().mul( vec2( uSimCols, uSimRows ) ), 'uvGrid' );
					// 2D Coordinate in Simulation Grid
					const simGrid2DIndex = temp( floor( uvGrid ), 'simGrid2DIndex' );
					// 2D Coordinate in Buffer Grid
					const bufferGrid2DIndex = temp( simGrid2DIndex.add( 1 ), 'bufferGrid2DIndex' );
					// 1D Coordinate in Buffer Grid
					const cellIndex = temp( bufferGrid2DIndex.x.add( bufferGrid2DIndex.y.mul( bufferCols ) ), 'cellIndex' );

					// Note: Calculate divergence value with actual value from buffers
					// Negate velX and velY to move cell and rotate arrow in proper direction (+x goes right +y goes up)
					const velX = velXRead.element( cellIndex );
					const velY = velYRead.element( cellIndex );
					// Since velocities are constantly changing, we need to reed them from the velocity storage buffers
					const outflow = calculateCellOutflowTSL(velXRead, velYRead, cellIndex, cellIndex.add( 1 ), cellIndex.add( uBufferCols ) );

					const samplePoint = temp(
						vec2(
							fract(uvGrid.x.add( timerLocal().mul( negate(velX) ) )),
							fract(uvGrid.y.add( timerLocal().mul( negate(velY) ) ))
						),
						'samplePoint'
					);

					// Get 0 to 1 uv coordinates of each cell
					const uvCell = fract(uvGrid);
					// Get -1 to 1 uv coordinates of each cell
					const uvCellNDC = uvCell.mul(2.0).sub(1.0);
					// Add angle in radians between x-axis and velocity vector
					const angle = atan2(negate(velY), negate(velX))
					// Set base rotation to allign with x axis
					angle.subAssign(radians(-90.0))
					// Rotate uv coordinates by angle determined by velocity. 
					const uvCellNDCRotated = rotateUVTSL(uvCellNDC, angle);
					// For some reason uvCellNDCRotated only works for box when it's written inline
					const boxSDF = sdfBoxTSL(rotateUVTSL(uvCell.mul(2.0).sub(1.0), angle), vec2(0.05, 0.6));
					const triangleSDF = sdfEquilateralTriangleTSL(uvCellNDCRotated, float(0.2), vec2(0.0, -0.5));
					// Combine box and triangle into arrow
					const arrowSDF = min(boxSDF, triangleSDF);
					const arrowCheck = temp(arrowSDF.lessThan(0.0), 'check');

					// Apply circle SDF with radius defined by the outflow
					// Put outflow in range of -1 to 1. The maximum outflow is maxVelocityX + maxVelocityY. The minimumn outflow is the inverse of the maximumn (i.e everything flowing in or everything flowing out)
					const normalizedOutflow = temp(outflow.div(maximumVelocity * 2), 'normalizedOutflow');
					const circleRadius = float(outflowIndicatorMaxRadius).mul(abs(normalizedOutflow));

					const circleSDF = temp(min(sdfCircleTSL(uvCellNDC, circleRadius), 0.01), 'circleSDF');
					const circleCheck = temp(circleSDF.lessThan(0.0), 'circleCheck');
					const textureColor = temp(
						texture(waterTexture, samplePoint),
						'textureColor'
					);

					// When outflow is positive, show green, else show black.
					const circleColor = temp( normalizedOutflow.lessThan(0.0).cond(black, green), 'circleColor');

					// Apply outflow indicator to color (green for outflow/production, black for inflow/destruction)
					textureColor.x.assign(mix(textureColor.x, circleColor.x, circleCheck));
					textureColor.y.assign(mix(textureColor.y, circleColor.y, circleCheck));
					textureColor.z.assign(mix(textureColor.z, circleColor.z, circleCheck));

					// Apply Arrow SDF to color
					textureColor.addAssign(white.mul(arrowCheck));

					// Apply Border on highlight 
					const isCellHighlighted = temp(cellIndex.equal(uSelectSimCell), 'isCellHighlighted');
					const borderColor = getBorderTSL(uvCell, 0.03).mul(isCellHighlighted);
					const finalColor = mix(textureColor.rgb, borderColor, max(borderColor.r, max(borderColor.g, borderColor.b)));
						
					return finalColor;
				})

				const nodeMaterial = new MeshBasicNodeMaterial();
				nodeMaterial.colorNode = divergenceFragmentNode();
				const mesh = new THREE.Mesh(geometry, nodeMaterial);

				sceneDivergencePlayground.add(mesh)

			}

			const setupSceneWindTunnel = () => {

				// Set resolution and determine grid cell height based on resolution
				const res = 100;
				const h = domainHeight / res;

				// Get wind tunnel buffer grid and simulation grid dimensions
				const { simCols, simRows } = getSimGridDimensions(h);
				const { bufferCols, bufferRows } = getBufferGridDimensions(simCols, simRows, 1);

				infoWindTunnel = {
					simCols: simCols,
					simRows: simRows,
					numSimCells: simCols * simRows,
					bufferCols: bufferCols,
					bufferRows: bufferRows,
					numBufferCells: bufferCols * bufferRows,
				}

				// Create buffers and uniforms specific to wind tunnel simulation
				const velXBufferAttribute = new StorageBufferAttribute( infoWindTunnel.numBufferCells, 1 );
				const velYBufferAttribute = new StorageBufferAttribute( infoWindTunnel.numBufferCells, 1 );
				const pressureBufferAttribute = new StorageBufferAttribute( infoWindTunnel.numBufferCells, 1 );
				const dBufferAttribute = new StorageBufferAttribute( infoWindTunnel.numBufferCells, 1 );
				const scalarBufferAttribute = new StorageBufferAttribute( infoWindTunnel.numBufferCells, 1 );

				const uOverRelaxation = uniform(1.9);
				const uCP = uniform(1000)
				const uDensity = uniform(1000);
				const uGravity = uniform(-9.81);

				infoWindTunnel.computeIntegration = tslFn(() => {

					const velYWriteBuffer = storage(velYStartBufferAttribute, 'float', numBufferCells);
					const cellIndex = getBufferCellIndexFromSimIndexTSL( uSimCols, uBufferCols );
					velYWriteBuffer.element(cellIndex).addAssign(gravityUniform.mul(deltaTimeUniform));

				})().compute( infoWindTunnel.numSimCells );

				createProjectionComputeShaders( velXBufferAttribute, velYBufferAttribute, pressureBufferAttribute, scalarBufferAttribute, infoWindTunnel );

				// Extrapolate velocity of buffer cells from surrounding simulation cells.
				// Effectively a post-processing part of the divergence/outflow/incompressibility step.
				// Shader is a bit of hack, making use of the fact that our grid dimensions are always square.
				infoWindTunnel.computeExtrapolateX = tslFn(() => {
					const velXReadWrite = storage(velXDivergenceBufferAttribute, 'float', 1);

					// Buffer cell to left of first simulation column
					const cellLeftBufferIndex = instanceIndex.mul(bufferCols);
					// Buffer cell to right of last simulation column
					const cellRightBufferIndex = cellLeftBufferIndex.add(bufferCols - 1);

					// Apply horizontal velocity of simulation cells to left and right buffer cells
					const leftBufferVelocity = velXReadWrite.element(cellLeftBufferIndex);
					leftBufferVelocity.assign(velXReadWrite.element(cellLeftBufferIndex.add(1)));

					const rightBufferVelocity = velXReadWrite.element(cellRightBufferIndex);
					rightBufferVelocity.assign(velXReadWrite.element(cellRightBufferIndex.sub(1)));

				})().compute(bufferRows); 

				infoWindTunnel.computeExtrapolateY = tslFn(() => {

					const velYReadWrite = storage(velYDivergenceBufferAttribute, 'float', 1);

					// Buffer cell below first simulation row
					const cellBottomBufferIndex = instanceIndex;
					// Buffer cell above last simulation row
					const cellTopBufferIndex = instanceIndex.add(bufferCols * bufferRows - 1);

					// Apply vertical velocity of simulation cells to top and bottom buffer cells
					const bottomBufferVelocity = velYReadWrite.element(cellBottomBufferIndex);
					bottomBufferVelocity.assign(velYReadWrite.element(cellBottomBufferIndex.add(1)));

					const topBufferVelocity = velYReadWrite.element(cellTopBufferIndex);
					topBufferVelocity.assign(velYReadWrite.element(cellTopBufferIndex.sub(1)));

				})().compute(bufferCols)


				infoWindTunnel.computeAdvectFluid = tslFn(() => {

				})().compute( infoWindTunnel.numBufferCells );

				infoWindTunnel.computeAdvectSmoke = tslFn(() => {

				})().compute( infoWindTunnel.numBufferCells )

				const returnColor = (r, g, b) => {
					return vec3(r, g, b);
				}

				const fs = createColorOutputTSL(1.0, 0.0, 0.0);

				sceneWindTunnel = new THREE.Scene();

				const geometry = new THREE.PlaneGeometry( 2, 2 );

				const simWithStorageQuad = new THREE.Mesh( geometry, new MeshBasicNodeMaterial({
					colorNode: fs(),
				}));
				sceneWindTunnel.add( simWithStorageQuad );

			}

			function init() {

				if ( WebGPU.isAvailable() === false ) {

					document.body.appendChild( WebGPU.getErrorMessage() );

					throw new Error( 'No WebGPU support' );

				}
				
				// Create renderer
				renderer = new WebGPURenderer( { antialias: true, canvas: canvas} );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				document.body.appendChild( renderer.domElement );
				window.addEventListener( 'resize', onWindowResize );

				// For now try to use same camera for each scene
				camera = new THREE.OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );

				// Create simulation height
				simHeight = 1.0
				cScale = canvas.height / simHeight;
				simWidth = canvas.width / cScale;
				domainHeight = 1.0;
				domainWidth = domainHeight / simHeight * simWidth;

				uSimCols = uniform(0);
				uSimRows = uniform(0);
				uBufferCols = uniform(0);
				uBufferRows = uniform(0);

				setupSceneDivergencePlayground();
				setupSceneWindTunnel();
				
				switchScene(currentSceneIndex);

				settings = {
					'Projection Iterations': 40,
					'Run Projection': 2,
					'Current Scene': 'Divergence Playground'
				};

				const gui = new GUI();

				const simulationFolder = gui.addFolder('Simulation');
				simulationFolder.add(settings, 'Current Scene', ['Divergence Playground', 'Wind Tunnel']).onChange(() => {
					switchScene( sceneEnum[ settings[ 'Current Scene' ] ] )
				});
				simulationFolder.add(settings, 'Projection Iterations', 10, 100).step(10);

				const debugFolder = gui.addFolder('Debug');
				debugFolder.add(uBufferCols, 'value').name('Buffer Cols')
				debugFolder.add(uBufferRows, 'value').name('Buffer Rows');
				debugFolder.add(uSimCols, 'value').name('Sim Cols');
				debugFolder.add(uSimRows, 'value').name('Sim Rows');


				renderer.setAnimationLoop( animate );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function animate() {

				// Apply external forces ( gravity, outside actors, etc. ) to velocity
				if ( infoCurrentScene.computeIntegration ) {

					renderer.compute(infoCurrentScene.integration);

				}

				// Compute divergence of each cell and project surrounding velocities 
				/*if (infoCurrentScene.computeProjection) {

					for (let i = 0; i < settings[ 'Projection Iterations' ]; i ++) {
						for ( let shaderIdx = 0; shaderIdx < infoCurrentScene.computeProjection.length; shaderIdx ++ ) {
							renderer.compute(infoCurrentScene.computeProjection[ shaderIdx ]);
						}
					}

				} */


				// Extrapolate velocities of buffer cells in each column
				if (infoCurrentScene.computeExtrapolateX) {

					renderer.compute(infoCurrentScene.computeExtrapolateX)
					
				}

				// Extrapolate velocities of buffer cells in each row
				if ( infoCurrentScene.computeExtrapolateY ) {

					renderer.compute( infoCurrentScene.computeExtrapolateY );

				}

				// Advect Fluid
				if ( infoCurrentScene.computeAdvectFluid ) {

					renderer.compute( infoCurrentScene.computeAdvectFluid );

				}

				// Advect Smoke
				if ( infoCurrentScene.computeAdvectSmoke ) {

					renderer.compute( infoCurrentScene.computeAdvectSmoke );

				}

				renderer.render(currentScene, camera);

			}

			init();
			console.log(uBufferCols)

		</script>
	</body>
</html>
