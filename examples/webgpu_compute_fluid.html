<html lang="en">
	<head>
		<title>three.js - WebGPU - Fluid Tunnel</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> WebGPU - Fluid Tunnel
		</div>
		<div id="container">
			<canvas id="c"></canvas>
		
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three';
			// In TSL, unless directly operating on a node, nearly every function you deploy needs to be imported from Nodes.js
			import { vec2, bool, vec3, vec4, rotate, hash, instancedArray, sqrt, attributeArray, sign, mix, uint, Fn, time, smoothstep, step, radians, atan, cos, sin, clamp, length, abs, min, max, float, timerDelta, cond, positionGeometry, varying, varyingProperty, floor, uv, If, temp, negate, storage, wgslFn, code, instanceIndex, uniform, Return, texture, fract, not } from 'three/tsl';

			import { GUI } from 'three/addons/libs/lil-gui.module.min.js';

			// Define objects shared across scenes
			// Same orthographic camera and WebGPU renderer used across both scenes.
			let camera, renderer, currentScene, currentSceneIndex, infoCurrentScene, settings;

			// Settings
			const perSceneObjects = {
				// Storage Buffer for each scene
				velXStorage: null,
				velXBufferAttributte: null,
				velYBufferAttribute: null,
				velYStorage: null,
				pressureStorage: null,
				scalarStorage: null,
				// Initial Simulation Grid Dimensions for each scene
				simCols: 0,
				simRows: 0,
				numSimCells: 0,
				bufferCols: 0,
				bufferRows: 0,
				numBufferCells: 0,
				// Compute shaders for each scene
				clearScalars: null,
				// Reset the pressure information
				computeResetPressure: null,
				// Account for external actors
				computeIntegration: null,
				// Projection/Divergence Step
				computeProjection: null,
				computeExtrapolateX: null,
				computeExtrapolateY: null,
				// Advection steps
				computeAdvectFluid: null,
				computeAdvectSmoke: null,
			};
			// TODO: Delete objects on scene switch then reinitialize later
			const effectController = {
				// Global settings that apply across scenes
				'Current Scene': 'Divergence Playground',
				divergenceIterations: 40,
				currentSimCols: uniform( 0 ),
				currentSimRows: uniform( 0 ),
				currentBufferCols: uniform( 0 ),
				currentBufferRows: uniform( 0 ),
				overRelaxation: uniform( 1.0 ),
				density: uniform( 1000 ),
				gravity: uniform( - 9.81 ),
				CP: uniform( 1000 ),
				// Scene Specific values
				'Divergence Playground': {
					...structuredClone( perSceneObjects ),
					initShaders: {
						'Random': null,
						'Alternate Vertical': null,
						'Alternate Horizontal': null,
						'Zero Velocity': null,
						'Converge Horizontal': null,
					},
					'Flow Map': 'Alternate Vertical',
					arrowOn: uniform( 1 ).label( 'arrowOn' ),
				},
				'Wind Tunnel': {
					...structuredClone( perSceneObjects ),
				}
			};

			// Scene info
			let sceneDivergencePlayground, sceneWindTunnel;
			const sceneEnum = {};
			const SCENE_DIVERGENCE_PLAYGROUND = sceneEnum[ 'Divergence Playground' ] = 0;
			const SCENE_WIND_TUNNEL = sceneEnum[ 'Wind Tunnel' ] = 1;

			const canvas = document.getElementById( 'c' );

			// Uniform across all scenes
			let simHeight, cScale, simWidth, domainHeight, domainWidth, res;

			// UTILITY FUNCTIONS
			// All functions use camelCase signatures.
			// Functions designated for use in TSL blocks have a TSL suffix.
			// Functions created with setLayout have their first letter capitalized.
			// Functions without these distinguishers are CPU functions
			// Examples:
			// CPU Function -> const fooFunc = (x) => return x;
			// TSL Function -> const fooFuncTSL = (x) => return x;
			// WGSL/GLSL Function -> const FooFunc = Fn( ( [ x ] ) => {
			// 		return x;
			// }).setLayout({
			// 		name: 'FooFunc',
			//		type: 'float',
			//		inputs: [{name: 'x', type: 'float'}]
			// })

			// FRAGMENT SHADER UTILITIES
			const RotateUV = Fn( ( [ point, angle ] ) => {

				const cosAngle = cos( angle );
				const sinAngle = sin( angle );
				const rotateX = cosAngle.mul( point.x ).add( sinAngle.mul( point.y ) );
				const rotateY = negate( sinAngle ).mul( point.x ).add( cosAngle.mul( point.y ) );
				return vec2( rotateX, rotateY );

			} ).setLayout( {
				name: 'rotateUV',
				type: 'vec2',
				inputs: [
					{ name: 'point', type: 'vec2' },
					{ name: 'angle', type: 'float' }
				]

			} );

			const GetBorder = Fn( ( [ p, width ] ) => {

				const w = vec2( width, width );
				const bl = step( w, p );
				const tr = step( w, negate( p ).add( 1.0 ) );
				const isBorder = abs( bl.x.mul( bl.y ).mul( tr.x ).mul( tr.y ).sub( 1.0 ) );
				return vec3( isBorder.mul( 0.0 ), isBorder.mul( 0.25 ), isBorder.mul( 1.0 ) );

			} ).setLayout( {
				name: 'GetBorder',
				type: 'vec3',
				inputs: [
					{ name: 'p', type: 'vec2' },
					{ name: 'width', type: 'float' }
				]
			} );

			const SDFCircle = Fn( ( [ p, r ] ) => {

				return length( p ).sub( r );

			} ).setLayout( {
				name: 'SDFCircle',
				type: 'float',
				inputs: [
					{ name: 'p', type: 'vec2' },
					{ name: 'r', type: 'float' }
				]
			} );

			const SDFBox = Fn( ( [ p, dims ] ) => {

				const d = abs( p ).sub( dims );
				return length( max( d, float( 0.0 ) ) ).add( min( max( d.x, d.y ), 0.0 ) );

			} ).setLayout( {
				name: 'SDFBox',
				type: 'float',
				inputs: [
					{ name: 'p', type: 'vec2' },
					{ name: 'dims', type: 'vec2' }
				]
			} );
			

			const SDFEquilateralTriangle = Fn( ( [ position, r, offset ] ) => {

				const p = position.toVar();
				p.addAssign( offset );
				const k = sqrt( 3.0 );
				p.x.assign( abs( p.x ).sub( r ) );
				p.y.assign( p.y.add( r.div( k ) ) );
				If( p.x.add( k.mul( p.y ) ).greaterThan( 0.0 ), () => {

					const x = p.x.sub( k.mul( p.y ) );
					const y = negate( k ).mul( p.x );
					y.subAssign( p.y );
					p.assign( vec2( x, y ).div( 2.0 ) );

				} );

				p.x.subAssign( clamp( p.x, r.mul( - 2.0 ), 0.0 ) );
				return negate( length( p ).mul( sign( p.y ) ) );

			} ).setLayout( {
				name: 'SDFEquilateralTriangle',
				type: 'float',
				inputs: [
					{ name: 'uvNode', type: 'vec2' },
					{ name: 'radiusNode', type: 'float' },
					{ name: 'offsetNode', type: 'vec2' }
				]
			} );

			const SDFArrow = Fn( ( [ p, velX, velY ] ) => {

				// Add angle in radians between x-axis and velocity vector
				const angle = atan( negate( velY ), velX );
				// Set base rotation to allign with x axis
				angle.subAssign( radians( - 90.0 ) );
				// Rotate uv coordinates by angle determined by velocity.
				const uvCellNDCRotated = rotate( p, angle );
				const boxSDF = SDFBox( rotate( p, angle ), vec2( 0.05, 0.6 ) );
				const triangleSDF = SDFEquilateralTriangle( uvCellNDCRotated, float( 0.2 ), vec2( 0.0, - 0.5 ) );
				// Combine box and triangle into arrow
				return min( boxSDF, triangleSDF );

			} ).setLayout( {
				name: 'SDFArrow',
				type: 'float',
				inputs: [
					{ name: 'p', type: 'vec2' },
					{ name: 'velX', type: 'float' },
					{ name: 'velY', type: 'float' }
				]
			} );

			// Dimension utility functions
			const getSimGridDimensions = ( h ) => {

				const simCols = Math.floor( domainWidth / h );
				const simRows = Math.floor( domainHeight / h );
				console.log( `simCols: ${simCols}, simRows: ${simRows}` );
				return { simCols, simRows };

			};

			const getBufferGridDimensions = ( simCols, simRows, cellBuffer ) => {
			
				// Buffered grid places new row and column on each relevant side
				const buffer = cellBuffer * 2;
				// Sim grid colums + buffer column left + buffer column right
				const bufferCols = simCols + buffer;
				// Sim grid rows + buffer row top + buffer row bottom
				const bufferRows = simRows + buffer;
				console.log( `bufferCols: ${bufferCols}, bufferRows: ${bufferRows}` );
				return { bufferCols, bufferRows };

			};

			// INDEXING UTILITIES

			// Convert a 1 dimensional cell index on the simulation grid to a 1 dimensional cell index on the buffer grid.
			//
			//                [ ][ ][ ][ ]
			//  [x][x]  --->  [ ][x][x][ ]
			//  [x][x]  --->  [ ][x][x][ ]
			//                [ ][ ][ ][ ]
			//
			// Sim Grid Indices 0,1,2,3 -> Buffer Grid Indices 5, 6, 9, 10
			const GetBufferCellIndexFromSimIndex = Fn( ( [
				// Copy of instanceIndex
				idx,
				// The dimensions of the simulation grid
				simCols,
				// The dimensions of the buffer grid
				bufferCols
			] ) => {

				// 2D index of sim grid cell (x, y)
				const simGridCol = idx.modInt( simCols ).toVar( 'simGridX' );
				const simGridRow = idx.div( simCols ).toVar( 'simGridY' );
				// 2D index of sim grid cell in buffered grid (x, y)
				const bufferGridCol = simGridCol.add( 1 ).toVar( 'bufferGridX' );
				const bufferGridRow = simGridRow.add( 1 ).toVar( 'bufferGridY' );
				// Convert to 1D index into buffered grid for storage buffer access
				return bufferGridCol.add( bufferGridRow.mul( bufferCols ) ).toVar( 'cellIndex' );
			
			} ).setLayout( {
				name: 'GetBufferCellIndexFromSimIndex',
				type: 'uint',
				inputs: [
					{ name: 'idx', type: 'uint' },
					{ name: 'simCols', type: 'uint' },
					{ name: 'bufferCols', type: 'uint' }
				]
			} );

			const getBufferCellIndexFromSimIndex = ( index, simCols, bufferCols ) => {

				const simGridX = index % simCols;
				const simGridY = Math.floor( index / simCols );
				const bufferGridX = simGridX + 1;
				const bufferGridY = simGridY + 1;
				return bufferGridY * bufferCols + bufferGridX;

			};

			const GetOffsetCellIndex = Fn( ( [
				idx,
				dispatchesX,
				offsetX,
				offsetY
			] ) => {

				const { currentBufferCols } = effectController;

				// Work in the coordinates of our non-adjacent cells compressed together into a separate grid
				// In a 2d compute execution context, these are analagous with the x and y ids of our threads
				// Convert indices of compact grid to non-adjacent simulation grid to buffer grid
				//                                    o=Sim Coord, x=Buff Coord   Shader Invocations
				//                                        [ ][ ][ ][ ][ ]          [x][x][x][x][x]
				//                      [x][ ][x]   --->  [ ][x][ ][x][ ]          [x][0][1][0][x]
				//       [x][x] ----->  [ ][ ][ ]   --->  [o][ ][o][ ][ ]          [x][2][3][2][x]
				//       [x][x] ----->  [x][ ][x]   --->  [ ][x][ ][x][ ]          [x][0][1][0][x]
				//                                        [o][ ][o][ ][ ]          [x][x][x][x][x]
				// Indices: 0,1,2,3 -> Indices 0,2,6,8 -> Indices 6,8,16,18
				const compactGridCol = idx.modInt( dispatchesX ).toVar( 'compactGridX' );
				const compactGridRow = idx.div( dispatchesX ).toVar( 'compactGridY' );

				// Get location of compact grid cell in sim grid cell space
				const simGridCol = compactGridCol.mul( 2 ).add( offsetX );
				const simGridRow = compactGridRow.mul( 2 ).add( offsetY );

				// Get index of sim grid cell in buffer grid (x, y)
				const bufferGridCol = simGridCol.add( 1 ).toVar( 'bufferGridX' );
				const bufferGridRow = simGridRow.add( 1 ).toVar( 'bufferGridY' );

				// Convert to 1D index into buffered grid for storage buffer access
				return bufferGridCol.add( bufferGridRow.mul( currentBufferCols ) ).toVar( 'cellIndex' );

			} ).setLayout( {
				name: 'GetOffsetCellIndex',
				type: 'uint',
				inputs: [
					{ name: 'idx', type: 'uint' },
					{ name: 'dispatchesX', type: 'uint' },
					{ name: 'offsetX', type: 'uint' },
					{ name: 'offsetY', type: 'uint' }
				]
			} );

			const getIndexedValuesFromStorageTSL = ( readBuffer, indices ) => {

				const nodes = [];
				for ( let i = 0; i < indices.length; i ++ ) {

					nodes.push( readBuffer.element( indices[ i ] ) );

				}

				return nodes;

			};

			const createClearScalarShader = ( info ) => {

				return Fn( () => {

					info.scalarStorage.element( instanceIndex ).assign( 0 );

				} )().compute( info.numBufferCells );

			};

			// COMPUTE UTILITIES

			// Projection / Divergence Step
			const calculateCellOutflow = ( velXArray, velYArray, cellIndex, bufferCols ) => {

				return ( velXArray[ cellIndex + 1 ] + velYArray[ cellIndex + bufferCols ] ) - ( velXArray[ cellIndex ] + velYArray[ cellIndex ] );

			};
			
			const calculateCellOutflowTSL = ( velXReadNode, velYReadNode, cellIndexNode, rIndexNode, uIndexNode ) => {

				// Current cell inflow represents negative outflow from current cell.
				const inflowIntoCell = velXReadNode.element( cellIndexNode ).add( velYReadNode.element( cellIndexNode ) );
				// Adjacent cell inflow represents positive outflow from current cell.
				const outflowFromCell = velXReadNode.element( rIndexNode ).add( velYReadNode.element( uIndexNode ) );
				// Subtract outflow by inflow
				return outflowFromCell.sub( inflowIntoCell );

			};

			const correctCellDivergenceTSL = ( velXNode, velYNode, scalarNode, pressureNode, cellIndexNode ) => {

				const { overRelaxation, currentBufferCols } = effectController;

				// Buffered grid allows us to access left and right cells this way without fear of overflow into next row
				const lIndex = cellIndexNode.sub( 1 ).toVar( 'cellLeftIndex' );
				const rIndex = cellIndexNode.add( 1 ).toVar( 'cellRightIndex' );
				// Add number of buffer cols to index up and down a row
				const uIndex = cellIndexNode.add( currentBufferCols ).toVar( 'cellAboveIndex' );
				const dIndex = cellIndexNode.sub( currentBufferCols ).toVar( 'cellBelowIndex' );
				const [ lScalar, rScalar, uScalar, dScalar ] = getIndexedValuesFromStorageTSL( scalarNode, [ lIndex, rIndex, uIndex, dIndex ]	 );
				const cellScalar = lScalar.add( rScalar ).add( uScalar ).add( dScalar ).toVar( 'cellScalar' );

				// All surrounding cells are obstacles, therefore, don't calculate this cell
				If( cellScalar.equal( 0.0 ), () => {

					Return();
			
				}	);

				const outflow = calculateCellOutflowTSL( velXNode, velYNode, cellIndexNode, rIndex, uIndex );
				const negativeOutflow = negate( outflow );

				const newPressure = negativeOutflow.div( cellScalar );
				newPressure.mulAssign( overRelaxation );

				pressureNode.element( cellIndexNode ).addAssign( newPressure );
				// Apply scalars to cell velocities
				// Velocity X
				velXNode.element( cellIndexNode ).subAssign( float( lScalar ).mul( newPressure ) );
				velXNode.element( rIndex ).addAssign( float( rScalar ).mul( newPressure ) );
				// Velocity Y
				velYNode.element( cellIndexNode ).subAssign( float( dScalar ).mul( newPressure ) );
				velYNode.element( uIndex ).addAssign( float( uScalar ).mul( newPressure ) );

			};

			// Calculate the number of dispatches in each of the four projection shaders
			const calculateDivergenceStepDispatches = ( numCols, numRows, offsetX, offsetY ) => {

				const dispatchX = Math.floor( ( numCols + 1 - offsetX ) / 2 );
				const dispatchY = Math.floor( ( numRows + 1 - offsetY ) / 2 );
				return { dispatchX, dispatchY };
			
			};

			const createProjectionComputeShaders = ( velXStorage, velYStorage, pressureStorage, scalarStorage, sceneInfo ) => {

				const createProjectionShader = ( offsetX, offsetY ) => {

					const { dispatchX, dispatchY } = calculateDivergenceStepDispatches( sceneInfo.simCols, sceneInfo.simRows, offsetX, offsetY );
					const dispatches = dispatchX * dispatchY;

					return Fn( () => {

						const cellIndex = GetOffsetCellIndex( instanceIndex, uint( dispatchX ), uint( offsetX ), uint( offsetY ) );
						correctCellDivergenceTSL( velXStorage, velYStorage, scalarStorage, pressureStorage, cellIndex );

					} )().compute( dispatches );

				};

				// Assign properly alligned divergence shaders to compute projection step
				sceneInfo.computeProjection = [
					createProjectionShader( 0, 0 ),
					createProjectionShader( 1, 0 ),
					createProjectionShader( 0, 1 ),
					createProjectionShader( 1, 1 )
				];
			
			};

			// Advection step
			// Fan out to all cells immediately to the current cell's left, average their velocities with the current cell
			const averageVelocityYTSL = ( velYReadNode, cellIndex ) => {

				const yCurrent = velYReadNode.element( cellIndex );
				const yLeft = velYReadNode.element( cellIndex.sub( 1 ) );
				const yUpperLeft = velYReadNode.element( cellIndex.sub( 1 ).add( currentBufferCols ) );
				const yUp = velYReadNode.element( cellIndex.add( currentBufferCols ) );

				const velocities = yCurrent.add( yLeft ).add( yUpperLeft ).add( yUp );

				return velocities.mul( 0.25 );

			};

			const averageVelocityXTSL = ( velXReadNode, cellIndex ) => {

				const xCurrent = velXReadNode.element( cellIndex );
				const xRight = velXReadNode.element( cellIndex.add( 1 ) );

				const velocities = float( 1.0 );
				return velocities.mul( 0.25 );

			};

			
			const U_FIELD = 0;
			const V_FIELD = 1;
			const S_FIELD = 2;


			const sampleFieldTSL = ( fieldEnumNode, fieldToReadNode ) => {

				const { currentBufferCols, currentBufferRows } = effectController;

				const x = max( min( x, currentBufferCols.mul( h ) ), h );
				const y = max( min( y, currentBufferRows.mul( h ) ), h );

				const notUField = not( fieldNode.equal( U_FIELD ) );
				const notVField = not( fieldNode.equal( V_FIELD ) );
				const h2 = float( h ).mul( h );
				const h1 = float( 1.0 ).div( h );

				const dx = notUField.mul( h2 );
				const dy = notVField.mul( h2 );

				const xDiff = x.sub( dx );
				const yDiff = y.sub( dy );


				const x0 = min( floor( xDiff.mul( h1 ) ), currentBufferCols.sub( 1 ) );
				const tx = ( xDiff.sub( x0.mul( h ) ) ).mul( h1 );
				const x1 = min( x0.add( 1 ), currentBufferCols.sub( 1 ) );

				const y0 = min( floor( yDiff.mul( h1 ) ), currentBufferRows.sub( 1 ) );
				const ty = ( yDiff.sub( y0.mul( h ) ) ).mul( h1 );
				const y1 = Math.min( y0.add( 1 ), currentBufferRows.sub( 1 ) );

				const sx = float( 1.0 ).sub( tx );
				const sy = float( 1.0 ).sub( ty );

				const sxsy = sx.mul( sy );
				const txsy = tx.mul( sy );
				const txty = tx.mul( ty );
				const sxty = sx.mul( ty );

				const val = sxsy.mul( fieldToReadNode.element( y0.mul( currentBufferCols ).add( x0 ) ) );
				val.addAssign( txsy.mul( fieldToReadNode.element( y0.mul( currentBufferCols ).add( x1 ) ) ) );
				val.addAssign( sxty.mul( fieldToReadNode.element( y1.mul( currentBufferCols ).add( x0 ) ) ) );
				val.addAssign( txty.mul( fieldToReadNode.element( y1.mul( currentBufferCols ).add( x1 ) ) ) );

				return val;

			};

			// Scene setup utils

			const switchScene = ( sceneIndex ) => {

				currentSceneIndex = sceneIndex;

				switch ( sceneIndex ) {

					case SCENE_DIVERGENCE_PLAYGROUND: {

						infoCurrentScene = effectController[ 'Divergence Playground' ];
						currentScene = sceneDivergencePlayground;
						effectController.divergenceIterations = 1;
						break;

					}

					case SCENE_WIND_TUNNEL: {

						infoCurrentScene = effectController[ 'Wind Tunnel' ];
						effectController.divergenceIterations = 80;
						currentScene = sceneWindTunnel;
						break;
			
					}
			
				}

				// Reassign global uniforms based on current scene
				effectController.currentSimCols.value = infoCurrentScene.simCols;
				effectController.currentSimRows.value = infoCurrentScene.simRows;
				effectController.currentBufferCols.value = infoCurrentScene.bufferCols;
				effectController.currentBufferRows.value = infoCurrentScene.bufferRows;

			};

			const setupSceneDivergencePlayground = () => {

				// Constants specific to divergence playground
				const outflowIndicatorMaxRadius = 0.5;
				const maximumVelocity = 4.0;

				// Calculate proper cell height
				const res = 30;
				const h = domainHeight / res;

				// Get proper buffer grid and simulation grid dimensions
				const { simCols, simRows } = getSimGridDimensions( h );
				const { bufferCols, bufferRows } = getBufferGridDimensions( simCols, simRows, 1 );

				const divergencePlaygroundInfo = effectController[ 'Divergence Playground' ];

				// Create scene info template, which gets filled out as we initialize this scene
				divergencePlaygroundInfo.simCols = simCols;
				divergencePlaygroundInfo.simRows = simRows;
				divergencePlaygroundInfo.numSimCells = simCols * simRows;
				divergencePlaygroundInfo.bufferCols = bufferCols;
				divergencePlaygroundInfo.bufferRows = bufferRows;
				divergencePlaygroundInfo.numBufferCells = bufferCols * bufferRows;

				// Scene specific uniforms
				const uSelectSimCell = uniform( 13 );

				// Scene specific Web API events
				canvas.addEventListener( 'mousemove', ( event ) => {

					const cellWidth = canvas.clientWidth / simCols;
					const cellHeight = canvas.clientHeight / simRows;
					const cellX = Math.floor( event.clientX / cellWidth );
					const cellY = Math.floor( ( canvas.clientHeight - event.clientY ) / cellHeight );

					const cellBufferX = cellX + 1;
					const cellBufferY = cellY + 1;
					const cellIndex = cellBufferX + cellBufferY * bufferCols;
					uSelectSimCell.value = cellIndex;

				} );

				// Create buffers for compute calculations
				const velXStorage = instancedArray( divergencePlaygroundInfo.numBufferCells );
				const velYStorage = instancedArray( divergencePlaygroundInfo.numBufferCells );
				const pressureStorage = instancedArray( divergencePlaygroundInfo.numBufferCells );
				const scalarStorage = instancedArray( divergencePlaygroundInfo.numBufferCells, 'uint' );

				const correctSingleCellDivergence = Fn( () => {

					correctCellDivergenceTSL( velXStorage, velYStorage, scalarStorage, pressureStorage, uSelectSimCell );

				} )().compute( 1 );

				const addObstacle = Fn( () => {

					const cellIndex = GetBufferCellIndexFromSimIndex( uSelectSimCell );
					scalarStorage.element( cellIndex ).assign( 0 );

				} )().compute( 1 );

				canvas.addEventListener( 'click', ( event ) => {

					//renderer.compute( addObstacle );

					for ( const projectionShader of divergencePlaygroundInfo.computeProjection ) {

						renderer.compute( projectionShader );

					}

				} );

				// Initialize all cells as obstacles at first
				divergencePlaygroundInfo.clearScalar = createClearScalarShader( divergencePlaygroundInfo );
				renderer.compute( divergencePlaygroundInfo.clearScalars );

				divergencePlaygroundInfo.computeResetPressure = Fn( () => {

					pressureStorage.element( instanceIndex ).assign( 0.0 );

			
				} )().compute( divergencePlaygroundInfo.numSimCells );
			
				// Pseudo-Random (not really since hash is static)
				divergencePlaygroundInfo.initShaders[ 'Random' ] = Fn( () => {

					const { currentSimCols, currentBufferCols } = effectController;

					const cellIndex = GetBufferCellIndexFromSimIndex( instanceIndex, currentSimCols, currentBufferCols );
					const randX = hash( instanceIndex );
					const randY = hash( instanceIndex.add( 2 ) );
					velXStorage.element( cellIndex ).assign( floor(
						randX.mul( float( maximumVelocity ).mul( 2 ) ).sub( maximumVelocity )
					) );
					velYStorage.element( cellIndex ).assign( floor(
						randY.mul( float( maximumVelocity ).mul( 2 ) ).sub( maximumVelocity )
					) );

					scalarStorage.element( cellIndex ).assign( 1 );
			
				} )().compute( divergencePlaygroundInfo.numSimCells );


				// Alternate vertical velocity in each cell
				divergencePlaygroundInfo.initShaders[ 'Alternate Vertical' ] = Fn( () => {

					const { currentSimCols, currentBufferCols } = effectController;

					const cellIndex = GetBufferCellIndexFromSimIndex( instanceIndex, currentSimCols, currentBufferCols );
					const isUp = cellIndex.modInt( 2 );
					velXStorage.element( cellIndex ).assign( 0 );
					velYStorage.element( cellIndex ).assign( isUp.equal( 0 ).select( 4, - 4 ) );

					scalarStorage.element( cellIndex ).assign( 1 );
			
				} )().compute( divergencePlaygroundInfo.numSimCells );

				// Alternate horizontal velocity in each cell
				divergencePlaygroundInfo.initShaders[ 'Alternate Horizontal' ] = Fn( () => {

					const { currentSimCols, currentBufferCols } = effectController;

					const cellIndex = GetBufferCellIndexFromSimIndex( instanceIndex, currentSimCols, currentBufferCols );
					const isUp = instanceIndex.modInt( currentSimCols ).modInt( 2 );
					velXStorage.element( cellIndex ).assign( isUp.equal( 0 ).select( 4, - 4 ) );
					velYStorage.element( cellIndex ).assign( 0 );

					scalarStorage.element( cellIndex ).assign( 1 );
			
				} )().compute( divergencePlaygroundInfo.numSimCells );

				divergencePlaygroundInfo.initShaders[ 'Zero Velocity' ] = Fn( () => {

					const { currentSimCols, currentBufferCols } = effectController;

					const cellIndex = GetBufferCellIndexFromSimIndex( instanceIndex, currentSimCols, currentBufferCols );
					velXStorage.element( cellIndex ).assign( 0 );
					velYStorage.element( cellIndex ).assign( 0 );

					scalarStorage.element( cellIndex ).assign( 1 );
			
				} )().compute( divergencePlaygroundInfo.numSimCells );

				divergencePlaygroundInfo.initShaders[ 'Converge Horizontal' ] = Fn( () => {

					const { currentSimCols, currentBufferCols } = effectController;

					const halfSize = currentSimCols.div( 2 );

					const isLeftSide = instanceIndex.modInt( currentSimCols ).div( halfSize );

					const cellIndex = GetBufferCellIndexFromSimIndex( instanceIndex, currentSimCols, currentBufferCols );
					velXStorage.element( cellIndex ).assign( isLeftSide.equal( 0 ).select( 4, - 4 ) );
					velYStorage.element( cellIndex ).assign( 0 );
					scalarStorage.element( cellIndex ).assign( 1 );
			
				} )().compute( divergencePlaygroundInfo.numSimCells );

				const initialFlowMap = divergencePlaygroundInfo[ 'Flow Map' ];

				renderer.compute( divergencePlaygroundInfo.initShaders[ initialFlowMap ] );

				// Create Compute Shaders
				createProjectionComputeShaders( velXStorage, velYStorage, pressureStorage, scalarStorage, effectController[ 'Divergence Playground' ] );
				effectController[ 'Divergence Playground' ][ 'Run Divergence Step' ] = () => {

					for ( let i = 0; i < effectController.divergenceIterations; i ++ ) {
			
						for ( const projectionShader of effectController[ 'Divergence Playground' ].computeProjection ) {

							renderer.compute( projectionShader );

						}
			
					}

				};

				// Create visualizer
				sceneDivergencePlayground = new THREE.Scene();

				const quadWidth = 2 / simCols;
				const quadHeight = 2 / simRows;

				//const geometry = new THREE.PlaneGeometry(quadWidth, quadHeight);
				const geometry = new THREE.PlaneGeometry( 2, 2 );

				const textureLoader = new THREE.TextureLoader();
				const waterTexture = textureLoader.load( 'textures/water/WaterTexture.png' );
				waterTexture.wrapS = THREE.RepeatWrapping;
				waterTexture.wrapT = THREE.RepeatWrapping;
			
				// Create color constants
				const white = vec4( 1.0, 1.0, 1.0, 1.0 );
				const green = vec4( 0.0, 1.0, 0.0, 1.0 );
				const black = vec4( 0.0, 0.0, 0.0, 1.0 );
			
				const divergenceFragmentNode = Fn( () => {

					const { currentSimCols, currentSimRows, currentBufferCols } = effectController;
					const { arrowOn } = effectController[ 'Divergence Playground' ];

					const velXRead = velXStorage;
					const velYRead = velYStorage;

					const uvGrid = uv().mul( vec2( currentSimCols, currentSimRows ) ).toVar( 'uvGridNode' );
					// 2D Coordinate in Simulation Grid
					const simGrid2DIndex = floor( uvGrid ).toVar( 'simGrid2DIndex' );
					// 2D Coordinate in Buffer Grid
					const bufferGrid2DIndex = simGrid2DIndex.add( 1 ).toVar( 'bufferGrid2DIndex' );
					// 1D Coordinate in Buffer Grid
					const cellIndex = bufferGrid2DIndex.x.add( bufferGrid2DIndex.y.mul( bufferCols ) ).toVar( 'cellIndex' );

					// Note: Calculate divergence value with actual value from buffers
					// Negate velX and velY to move cell and rotate arrow in proper direction (+x goes right +y goes up)
					const velX = velXRead.element( cellIndex );
					const velY = velYRead.element( cellIndex );
					// Since velocities are constantly changing, we need to reed them from the velocity storage buffers
					const outflow = calculateCellOutflowTSL( velXRead, velYRead, cellIndex, cellIndex.add( 1 ), cellIndex.add( currentBufferCols ) );

					const samplePoint = vec2(
						fract( uvGrid.x.add( time.mul( negate( velX ) ) ) ),
						fract( uvGrid.y.add( time.mul( negate( velY ) ) ) )
					).toVar( 'samplePoint' );


					// Get 0 to 1 uv coordinates of each cell
					const uvCell = fract( uvGrid );
					// Get -1 to 1 uv coordinates of each cell
					const uvCellNDC = uvCell.mul( 2.0 ).sub( 1.0 );

					// Apply circle SDF with radius defined by the outflow
					// Put outflow in range of -1 to 1. The maximum outflow is maxVelocityX + maxVelocityY. The minimumn outflow is the inverse of the maximumn (i.e everything flowing in or everything flowing out)
					const normalizedOutflow = outflow.div( maximumVelocity * 2 ).toVar( 'normalizedOutflow' );
					const circleRadius = float( outflowIndicatorMaxRadius ).mul( abs( normalizedOutflow ) );

					const circleSDF = min( SDFCircle( uvCellNDC, circleRadius ), 0.01 ).toVar( 'circleSDF' );
					const circleCheck = circleSDF.lessThan( 0.0 ).toVar( 'circleCheck' );
					const textureColor = texture( waterTexture, samplePoint ).toVar( 'textureColor' );

					// When outflow is positive, show green, else show black.
					const circleColor = normalizedOutflow.lessThan( 0.0 ).select( black, green ).toVar( 'circleColor' );

					// Apply outflow indicator to color (green for outflow/production, black for inflow/destruction)
					textureColor.x.assign( mix( textureColor.x, circleColor.x, circleCheck ) );
					textureColor.y.assign( mix( textureColor.y, circleColor.y, circleCheck ) );
					textureColor.z.assign( mix( textureColor.z, circleColor.z, circleCheck ) );

					If( arrowOn.equal( 1 ), () => {

						const arrowSDF = SDFArrow( uvCellNDC, velX, velY );

						textureColor.assign( mix( white, textureColor, smoothstep( 0.0, 0.02, arrowSDF ) ) );


					} );

					// Apply Border on highlight
					const isCellHighlighted = cellIndex.equal( uSelectSimCell ).toVar( 'isCellHighlighted' );
					const borderColor = GetBorder( uvCell, 0.03 ).mul( isCellHighlighted );
					const finalColor = mix( textureColor.rgb, borderColor, max( borderColor.r, max( borderColor.g, borderColor.b ) ) );
			
					return finalColor;
			
				} );

				const nodeMaterial = new THREE.MeshBasicNodeMaterial();
				nodeMaterial.colorNode = divergenceFragmentNode();
				const mesh = new THREE.Mesh( geometry, nodeMaterial );

				sceneDivergencePlayground.add( mesh );

			};

			const setupSceneWindTunnel = () => {

				// Set resolution and determine grid cell height based on resolution
				const res = 200;
				const h = domainHeight / res;

				// Get wind tunnel buffer grid and simulation grid dimensions
				const { simCols, simRows } = getSimGridDimensions( h );
				const { bufferCols, bufferRows } = getBufferGridDimensions( simCols, simRows, 1 );

				effectController[ 'Wind Tunnel' ].simCols = simCols;
				effectController[ 'Wind Tunnel' ].simRows = simRows;
				effectController[ 'Wind Tunnel' ].numSimCells = simCols * simRows;
				effectController[ 'Wind Tunnel' ].bufferCols = bufferCols;
				effectController[ 'Wind Tunnel' ].bufferRows = bufferRows;
				effectController[ 'Wind Tunnel' ].numBufferCells = bufferCols * bufferRows;

				// Create buffers and uniforms specific to wind tunnel simulation
				const velXStorage = attributeArray( effectController[ 'Wind Tunnel' ].numBufferCells );
				const velYStorage = attributeArray( effectController[ 'Wind Tunnel' ].numBufferCells );
				const pressureStorage = attributeArray( effectController[ 'Wind Tunnel' ].numBufferCells );
				const scalarStorage = attributeArray( effectController[ 'Wind Tunnel' ].numBufferCells, 'uint' );

				effectController[ 'Wind Tunnel' ].computeIntegration = Fn( () => {

					const { gravity, denssity, currentSimCols, currentBufferCols } = effectController;

					const cellIndex = GetBufferCellIndexFromSimIndex( instanceIndex, currentSimCols, currentBufferCols );
					velYStorage.element( cellIndex ).addAssign( gravity.mul( time ) );

				} )().compute( effectController[ 'Wind Tunnel' ].numSimCells );

				createProjectionComputeShaders( velXStorage, velYStorage, pressureStorage, scalarStorage, effectController[ 'Wind Tunnel' ] );

				// Extrapolate velocity of buffer cells from surrounding simulation cells.
				// Effectively a post-processing part of the divergence/outflow/incompressibility step.
				// Shader is a bit of hack, making use of the fact that our grid dimensions are always square.
				effectController[ 'Wind Tunnel' ].computeExtrapolateX = Fn( () => {

					// Buffer cell to left of first simulation column
					const cellLeftBufferIndex = instanceIndex.mul( bufferCols );
					// Buffer cell to right of last simulation column
					const cellRightBufferIndex = cellLeftBufferIndex.add( bufferCols - 1 );

					// Apply horizontal velocity of simulation cells to left and right buffer cells
					const leftBufferVelocity = velXStorage.element( cellLeftBufferIndex );
					leftBufferVelocity.assign( velXStorage.element( cellLeftBufferIndex.add( 1 ) ) );

					const rightBufferVelocity = velXStorage.element( cellRightBufferIndex );
					rightBufferVelocity.assign( velXStorage.element( cellRightBufferIndex.sub( 1 ) ) );

				} )().compute( bufferRows );

				effectController[ 'Wind Tunnel' ].computeExtrapolateY = Fn( () => {

					// Buffer cell below first simulation row
					const cellBottomBufferIndex = instanceIndex;
					// Buffer cell above last simulation row
					const cellTopBufferIndex = instanceIndex.add( bufferCols * bufferRows - 1 );

					// Apply vertical velocity of simulation cells to top and bottom buffer cells
					const bottomBufferVelocity = velYStorage.element( cellBottomBufferIndex );
					bottomBufferVelocity.assign( velYStorage.element( cellBottomBufferIndex.add( 1 ) ) );

					const topBufferVelocity = velYStorage.element( cellTopBufferIndex );
					topBufferVelocity.assign( velYStorage.element( cellTopBufferIndex.sub( 1 ) ) );

				} )().compute( bufferCols );


				// Advect u
				effectController[ 'Wind Tunnel' ].computeAdvectFluidX = Fn( () => {

					const { currentSimCols, currentBufferCols } = effectController;

					const cellIndex = GetBufferCellIndexFromSimIndex( currentSimCols + 1, currentBufferCols );

					const scalarCell = scalarStorage.element( cellIndex );
					const scalarCellLeft = scalarStorage.element( cellIndex.sub( 1 ) );

					// If there is nowhere for the velocity to advect frokm
					If( scalarCell.equal( 0.0 ).or( scalarCellLeft.equal( 0.0 ) ), () => {

						Return();

					} );

					const x = float( 1.0 );
					const y = float( 1.0 );

					const velX = velXStorage.element( cellIndex );
					const velY = averageVelocityYTSL( velYStorage, cellIndex );
					x.subAssign( velX.mul( timerDelta() ) );
					y.subAssign( velY.mul( timerDelta() ) );

					velX.assign( sampleFieldTSL( U_FIELD, velXStorage ) );


				} )().compute( ( effectController[ 'Wind Tunnel' ].simCols + 1 ) * effectController[ 'Wind Tunnel' ].simRows );

				effectController[ 'Wind Tunnel' ].computeAdvectFluidY;

				effectController[ 'Wind Tunnel' ].computeAdvectSmoke = Fn( () => {

					const { currentSimCols, currentBufferCols } = effectController;

					const cellIndex = GetBufferCellIndexFromSimIndex( currentSimCols, currentBufferCols );

					const velX = velXStorage.element( cellIndex );
					const velXRight = velXStorage.element( cellIndex.add( 1 ) );
					const newX = float( 0.5 ).mul( velX.add( velXRight ) );
			
					const velY = velYStorage.element( cellIndex );
					const velYUp = velYStorage.element( cellIndex + currentBufferCols );
					const newY = float( 0.5 ).mul( velY.add( velYUp ) );

				} )().compute( effectController[ 'Wind Tunnel' ].numSimCells );

				sceneWindTunnel = new THREE.Scene();

				const geometry = new THREE.PlaneGeometry( 2, 2 );

				const simWithStorageQuad = new THREE.Mesh( geometry, new THREE.MeshBasicNodeMaterial( {
					colorNode: Fn( () => {

						return vec3( 1.0, 0.0, 0.0 );
			
					} )(),
				} ) );
				sceneWindTunnel.add( simWithStorageQuad );

			};

			function init() {
			
				// Create renderer
				renderer = new THREE.WebGPURenderer( { antialias: true, canvas: canvas } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				document.body.appendChild( renderer.domElement );
				window.addEventListener( 'resize', onWindowResize );

				// Use same camera for each scene
				camera = new THREE.OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );

				// Create simulation height
				simHeight = 1.0;
				cScale = canvas.height / simHeight;
				simWidth = canvas.width / cScale;
				domainHeight = 1.0;
				domainWidth = domainHeight / simHeight * simWidth;

				console.log( `Window Dimensions : ${window.innerWidth} x ${window.innerHeight}` );
				console.log( `Canvas Dimensions: ${canvas.width} x ${canvas.height}` );
				console.log( `Simulation Scale: ${cScale}` );
				console.log();

				setupSceneDivergencePlayground();
				setupSceneWindTunnel();
			
				switchScene( SCENE_DIVERGENCE_PLAYGROUND );

				settings = {
					'Current Scene': 'Divergence Playground',
				};

				const gui = new GUI();
				gui.addFolder( 'View Console For Further Sim Details' );

				const simulationFolder = gui.addFolder( 'Simulation' );
				simulationFolder.add( settings, 'Current Scene', [ 'Divergence Playground', 'Wind Tunnel' ] ).onChange( () => {

					switchScene( sceneEnum[ settings[ 'Current Scene' ] ] );
			
				} );
				simulationFolder.add( effectController, 'divergenceIterations', 1, 100 ).step( 1 ).name( 'Divergence Iterations' );
				simulationFolder.add( effectController.overRelaxation, 'value', 1.0, 1.9 ).step( 0.1 ).name( 'Over Relaxation' );

				const divergencePlaygroundFolder = gui.addFolder( 'Divergence Playground' );
				divergencePlaygroundFolder.add( effectController[ 'Divergence Playground' ], 'Run Divergence Step' );
				divergencePlaygroundFolder.add( effectController[ 'Divergence Playground' ].arrowOn, 'value', [ 0, 1 ] );
				divergencePlaygroundFolder.add(
					effectController[ 'Divergence Playground' ],
					'Flow Map',
					[ 'Random', 'Alternate Vertical', 'Alternate Horizontal', 'Zero Velocity', 'Converge Horizontal' ]
				).onChange( () => {

					const divergencePlaygroundInfo = effectController[ 'Divergence Playground' ];
					const currentFlowMap = effectController[ 'Divergence Playground' ][ 'Flow Map' ];
					const initShader = effectController[ 'Divergence Playground' ].initShaders[ currentFlowMap ];
					renderer.compute( initShader );


				} ).name( 'arrowOn' );

				const windTunnelFolder = gui.addFolder( 'Wind Tunnel' );


				renderer.setAnimationLoop( animate );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function animate() {

				if ( infoCurrentScene.computeResetPressure ) {

					renderer.compute( infoCurrentScene.computeResetPressure );
			
				}

				// Apply external forces ( gravity, outside actors, user chicanery) to velocity
				if ( infoCurrentScene.computeIntegration ) {

					renderer.compute( infoCurrentScene.computeIntegration );

				}

				// Compute divergence of each cell and project surrounding velocities
				// Divergence is computed on user input in the divergence playground,
				// not synchronously with the render input.
				if ( infoCurrentScene.computeProjection && currentSceneIndex !== SCENE_DIVERGENCE_PLAYGROUND ) {

					for ( let i = 0; i < effectController.divergenceIterations; i ++ ) {

						for ( const projectionShader of infoCurrentScene.computeProjection ) {

							renderer.compute( projectionShader );

						}
			
					}

				}

				// Extrapolate velocities of buffer cells in each column
				if ( infoCurrentScene.computeExtrapolateX ) {

					renderer.compute( infoCurrentScene.computeExtrapolateX );

				}

				// Extrapolate velocities of buffer cells in each row
				if ( infoCurrentScene.computeExtrapolateY ) {

					renderer.compute( infoCurrentScene.computeExtrapolateY );

				}

				// Advect Fluid
				if ( infoCurrentScene.computeAdvectFluid ) {

					renderer.compute( infoCurrentScene.computeAdvectFluid );

				}

				// Advect Smoke
				if ( infoCurrentScene.computeAdvectSmoke ) {

					renderer.compute( infoCurrentScene.computeAdvectSmoke );

				}

				renderer.render( currentScene, camera );

			}

			init();

		</script>
	</body>
</html>