<html lang="en">
	<head>
		<title>three.js - WebGPU - Fluid Tunnel</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> WebGPU - Fluid Tunnel
		</div>
		<div id="container">
			<canvas id="c"></canvas>
		
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three';
			// In TSL, unless directly operating on a node, nearly every function you deploy needs to be imported from Nodes.js
			import { vec2, vec3, vec4, rotate, sqrt, sign, mix, uint, Fn, time, smoothstep, step, radians, atan, cos, sin, clamp, length, abs, min, max, float, timerDelta, cond, positionGeometry, varying, varyingProperty, floor, uv, If, temp, negate, storage, wgslFn, code, instanceIndex, uniform, Return, texture, fract, not } from 'three/tsl';

			import { GUI } from 'three/addons/libs/lil-gui.module.min.js';

			// Define objects shared across scenes
			// Same orthographic camera and WebGPU renderer used across both scenes.
			let camera, renderer, mouse, currentScene, currentSceneIndex, infoCurrentScene, settings;

			// Global uniforms
			let uSimCols, uSimRows, uBufferCols, uBufferRows, uOverRelaxation;

			// Scene info
			let infoDivergencePlayground, infoWindTunnel;
			let sceneDivergencePlayground, sceneWindTunnel;
			const SCENE_DIVERGENCE_PLAYGROUND = 0;
			const SCENE_WIND_TUNNEL = 1;
			const sceneEnum = {
				'Divergence Playground': SCENE_DIVERGENCE_PLAYGROUND,
				'Wind Tunnel': SCENE_WIND_TUNNEL
			};

			const canvas = document.getElementById( 'c' );

			// Uniform across all scenes
			let simHeight, cScale, simWidth, domainHeight, domainWidth, res;

			// UTILITY FUNCTIONS
			// All functions use camelCase signatures.
			// Functions designated for use in TSL blocks have a TSL suffix.
			// Functions created with setLayout have their first letter capitalized.
			// Functions without these distinguishers are CPU functions
			// Examples:
			// CPU Function -> const fooFunc = (x) => return x;
			// TSL Function -> const fooFuncTSL = (x) => return x;
			// WGSL/GLSL Function -> const FooFunc = Fn( ( [ x ] ) => {
			// 		return x;
			// }).setLayout({
			// 		name: 'FooFunc',
			//		type: 'float',
			//		inputs: [{name: 'x', type: 'float'}]
			// })

			// Dimension utility functions
			const getSimGridDimensions = ( h ) => {

				const simCols = Math.floor( domainWidth / h );
				const simRows = Math.floor( domainHeight / h );
				console.log( `simCols: ${simCols}, simRows: ${simRows}` );
				return { simCols, simRows };

			};

			const getBufferGridDimensions = ( simCols, simRows, cellBuffer ) => {
			
				// Buffered grid places new row and column on each relevant side
				const buffer = cellBuffer * 2;
				// Sim grid colums + buffer column left + buffer column right
				const bufferCols = simCols + buffer;
				// Sim grid rows + buffer row top + buffer row bottom
				const bufferRows = simRows + buffer;
				console.log( `bufferCols: ${bufferCols}, bufferRows: ${bufferRows}` );
				return { bufferCols, bufferRows };

			};

			// Indexing utility functions

			// Convert a 1 dimensional cell index on the simulation grid to a 1 dimensional cell index on the buffer grid
			const GetBufferCellIndexFromSimIndex = Fn( ( [
				// Copy of instanceIndex
				idx,
				// The dimensions of the simulation grid
				simCols,
				// The dimensions of the buffer grid
				bufferCols
			] ) => {

				// 2D index of sim grid cell (x, y)
				const simGridCol = idx.remainder( simCols ).toVar( 'simGridX' );
				const simGridRow = idx.div( simCols ).toVar( 'simGridY' );
				// 2D index of sim grid cell in buffered grid (x, y)
				const bufferGridCol = simGridCol.add( 1 ).toVar( 'bufferGridX' );
				const bufferGridRow = simGridRow.add( 1 ).toVar( 'bufferGridY' );
				// Convert to 1D index into buffered grid for storage buffer access
				return bufferGridCol.add( bufferGridRow.mul( bufferCols ) ).toVar( 'cellIndex' );
			
			} ).setLayout( {
				name: 'GetBufferCellIndexFromSimIndex',
				type: 'uint',
				inputs: [
					{ name: 'idx', type: 'uint' },
					{ name: 'simCols', type: 'uint' },
					{ name: 'bufferCols', type: 'uint' }
				]
			} );

			const getBufferCellIndexFromSimIndex = ( index, simCols, bufferCols ) => {

				const simGridX = index % simCols;
				const simGridY = Math.floor( index / simCols );
				const bufferGridX = simGridX + 1;
				const bufferGridY = simGridY + 1;
				return bufferGridY * bufferCols + bufferGridX;

			};

			const GetOffsetCellIndex = Fn( ( [
				idx,
				dispatchesX,
				offsetX,
				offsetY
			] ) => {

				// Work in the coordinates of our non-adjacent cells compressed together into a separate grid
				// In a 2d compute execution context, these are analagous with the x and y ids of our threads
				const compactGridCol = idx.modInt( dispatchesX ).toVar( 'compactGridX' );
				const compactGridRow = idx.div( dispatchesX ).toVar( 'compactGridY' );

				// Get location of compact grid cell in sim grid cell space
				const simGridCol = compactGridCol.mul( 2 ).add( offsetX );
				const simGridRow = compactGridRow.mul( 2 ).add( offsetY );

				// Get index of sim grid cell in buffer grid (x, y)
				const bufferGridCol = simGridCol.add( 1 ).toVar( 'bufferGridX' );
				const bufferGridRow = simGridRow.add( 1 ).toVar( 'bufferGridY' );

				// Convert to 1D index into buffered grid for storage buffer access
				return bufferGridCol.add( bufferGridRow.mul( uBufferCols ) ).toVar( 'cellIndex' );


			} ).setLayout( {
				name: 'GetOffsetCellIndex',
				type: 'uint',
				inputs: [
					{ name: 'idx', type: 'uint' },
					{ name: 'dispatchesX', type: 'uint' },
					{ name: 'offsetX', type: 'uint' },
					{ name: 'offsetY', type: 'uint' }
				]
			} );

			const getIndexedValuesFromStorageTSL = ( readBuffer, indices ) => {

				const nodes = [];
				for ( let i = 0; i < indices.length; i ++ ) {

					nodes.push( readBuffer.element( indices[ i ] ) );

				}

				return nodes;

			};

			// COMPUTE UTILITIES

			// Projection / Divergence Step
			const calculateCellOutflow = ( velXArray, velYArray, cellIndex, bufferCols ) => {

				return ( velXArray[ cellIndex + 1 ] + velYArray[ cellIndex + bufferCols ] ) - ( velXArray[ cellIndex ] + velYArray[ cellIndex ] );

			};
			
			const calculateCellOutflowTSL = ( velXReadNode, velYReadNode, cellIndexNode, rIndexNode, uIndexNode ) => {

				// Current cell inflow represents negative outflow from current cell.
				const inflowIntoCell = velXReadNode.element( cellIndexNode ).add( velYReadNode.element( cellIndexNode ) );
				// Adjacent cell inflow represents positive outflow from current cell.
				const outflowFromCell = velXReadNode.element( rIndexNode ).add( velYReadNode.element( uIndexNode ) );
				// Subtract outflow by inflow
				return outflowFromCell.sub( inflowIntoCell );

			};

			const correctCellDivergenceTSL = ( velXNode, velYNode, scalarNode, pressureNode, cellIndexNode ) => {

				const lIndex = cellIndexNode.sub( 1 ).toVar( 'cellLeftIndex' );
				const rIndex = cellIndexNode.add( 1 ).toVar( 'cellRightIndex' );
				// cell above, cell below
				const uIndex = cellIndexNode.add( uBufferCols ).toVar( 'cellAboveIndex' );
				const dIndex = cellIndexNode.sub( uBufferCols ).toVar( 'cellBelowIndex' );
				const [ lScalar, rScalar, uScalar, dScalar ] = getIndexedValuesFromStorageTSL( scalarNode, [ lIndex, rIndex, uIndex, dIndex ]	 );
				const cellScalar = lScalar.add( rScalar ).add( uScalar ).add( dScalar ).toVar( 'cellScalar' );

				If( cellScalar.equal( 0.0 ), () => {

					Return();
			
				}	);

				const outflow = calculateCellOutflowTSL( velXNode, velYNode, cellIndexNode, rIndex, uIndex );
				const negativeOutflow = negate( outflow );

				const newPressure = negativeOutflow.div( cellScalar );
				newPressure.mulAssign( uOverRelaxation );

				pressureNode.element( cellIndexNode ).addAssign( newPressure );
				// Apply scalars to cell velocities
				// Velocity X
				velXNode.element( cellIndexNode ).subAssign( float( lScalar ).mul( newPressure ) );
				velXNode.element( rIndex ).addAssign( float( rScalar ).mul( newPressure ) );
				// Velocity Y
				velYNode.element( cellIndexNode ).subAssign( float( dScalar ).mul( newPressure ) );
				velYNode.element( uIndex ).addAssign( float( uScalar ).mul( newPressure ) );

			};

			const calculateDivergenceStepDispatches = ( numCols, numRows, offsetX, offsetY ) => {

				const dispatchX = Math.floor( ( numCols + 1 - offsetX ) / 2 );
				const dispatchY = Math.floor( ( numRows + 1 - offsetY ) / 2 );
				return { dispatchX, dispatchY };
			
			};

			const createProjectionComputeShaders = ( velXAttrib, velYAttrib, pressureAttrib, scalarAttrib, sceneInfo ) => {

				// Create shader storage buffers
				const velXStorage = storage( velXAttrib, 'float', sceneInfo.numBufferCells );
				const velYStorage = storage( velYAttrib, 'float', sceneInfo.numBufferCells );
				const pressureStorage = storage( pressureAttrib, 'float', sceneInfo.numBufferCells );
				const scalarStorage = storage( scalarAttrib, 'uint', sceneInfo.numBufferCells );

				const createProjectionShader = ( offsetX, offsetY ) => {

					const { dispatchX, dispatchY } = calculateDivergenceStepDispatches( sceneInfo.simCols, sceneInfo.simRows, offsetX, offsetY );
					const dispatches = dispatchX * dispatchY;

					return Fn( () => {

						const cellIndex = GetOffsetCellIndex( instanceIndex, uint( dispatchX ), uint( offsetX ), uint( offsetY ) );
						correctCellDivergenceTSL( velXStorage, velYStorage, scalarStorage, pressureStorage, cellIndex );

					} )().compute( dispatches );

				};

				// Assign properly alligned divergence shaders to compute projection step
				sceneInfo.computeProjection = [
					createProjectionShader( 0, 0 ),
					createProjectionShader( 1, 0 ),
					createProjectionShader( 0, 1 ),
					createProjectionShader( 1, 1 )
				];
			
			};

			// Advection step
			// Fan out to all cells immediately to the current cell's left, average their velocities with the current cell
			const averageVelocityYTSL = ( velYReadNode, cellIndex ) => {

				const yCurrent = velYReadNode.element( cellIndex );
				const yLeft = velYReadNode.element( cellIndex.sub( 1 ) );
				const yUpperLeft = velYReadNode.element( cellIndex.sub( 1 ).add( uBufferCols ) );
				const yUp = velYReadNode.element( cellIndex.add( uBufferCols ) );

				const velocities = yCurrent.add( yLeft ).add( yUpperLeft ).add( yUp );

				return velocities.mul( 0.25 );

			};

			const averageVelocityXTSL = ( velXReadNode, cellIndex ) => {

				const xCurrent = velXReadNode.element( cellIndex );
				const xRight = velXReadNode.element( cellIndex.add( 1 ) );

				const velocities = float( 1.0 );
				return velocities.mul( 0.25 );

			};

			
			const U_FIELD = 0;
			const V_FIELD = 1;
			const S_FIELD = 2;


			const sampleFieldTSL = ( fieldEnumNode, fieldToReadNode ) => {

				const x = max( min( x, uBufferCols.mul( h ) ), h );
				const y = max( min( y, uBufferRows.mul( h ) ), h );

				const notUField = not( fieldNode.equal( U_FIELD ) );
				const notVField = not( fieldNode.equal( V_FIELD ) );
				const h2 = float( h ).mul( h );
				const h1 = float( 1.0 ).div( h );

				const dx = notUField.mul( h2 );
				const dy = notVField.mul( h2 );

				const xDiff = x.sub( dx );
				const yDiff = y.sub( dy );


				const x0 = min( floor( xDiff.mul( h1 ) ), uBufferCols.sub( 1 ) );
				const tx = ( xDiff.sub( x0.mul( h ) ) ).mul( h1 );
				const x1 = min( x0.add( 1 ), uBufferCols.sub( 1 ) );

				const y0 = min( floor( yDiff.mul( h1 ) ), uBufferRows.sub( 1 ) );
				const ty = ( yDiff.sub( y0.mul( h ) ) ).mul( h1 );
				const y1 = Math.min( y0.add( 1 ), uBufferRows.sub( 1 ) );

				const sx = float( 1.0 ).sub( tx );
				const sy = float( 1.0 ).sub( ty );

				const sxsy = sx.mul( sy );
				const txsy = tx.mul( sy );
				const txty = tx.mul( ty );
				const sxty = sx.mul( ty );

				const val = sxsy.mul( fieldToReadNode.element( y0.mul( uBufferCols ).add( x0 ) ) );
				val.addAssign( txsy.mul( fieldToReadNode.element( y0.mul( uBufferCols ).add( x1 ) ) ) );
				val.addAssign( sxty.mul( fieldToReadNode.element( y1.mul( uBufferCols ).add( x0 ) ) ) );
				val.addAssign( txty.mul( fieldToReadNode.element( y1.mul( uBufferCols ).add( x1 ) ) ) );

				return val;

			};
			
			const RotateUV = Fn( ( [ point, angle ] ) => {

				const cosAngle = cos( angle );
				const sinAngle = sin( angle );
				const rotateX = cosAngle.mul( point.x ).add( sinAngle.mul( point.y ) );
				const rotateY = negate( sinAngle ).mul( point.x ).add( cosAngle.mul( point.y ) );
				return vec2( rotateX, rotateY );

			} ).setLayout( {
				name: 'rotateUV',
				type: 'vec2',
				inputs: [
					{ name: 'point', type: 'vec2' },
					{ name: 'angle', type: 'float' }
				]

			} );

			const GetBorder = Fn( ( [ p, width ] ) => {

				const w = vec2( width, width );
				const bl = step( w, p );
				const tr = step( w, negate( p ).add( 1.0 ) );
				const isBorder = abs( bl.x.mul( bl.y ).mul( tr.x ).mul( tr.y ).sub( 1.0 ) );
				return vec3( isBorder.mul( 0.0 ), isBorder.mul( 0.25 ), isBorder.mul( 1.0 ) );

			} ).setLayout( {
				name: 'GetBorder',
				type: 'vec3',
				inputs: [
					{ name: 'p', type: 'vec2' },
					{ name: 'width', type: 'float' }
				]
			} );

			const SDFCircle = Fn( ( [ p, r ] ) => {

				return length( p ).sub( r );

			} ).setLayout( {
				name: 'SDFCircle',
				type: 'float',
				inputs: [
					{ name: 'p', type: 'vec2' },
					{ name: 'r', type: 'float' }
				]
			} );

			const SDFBox = Fn( ( [ p, dims ] ) => {

				const d = abs( p ).sub( dims );
				return length( max( d, float( 0.0 ) ) ).add( min( max( d.x, d.y ), 0.0 ) );

			} ).setLayout( {
				name: 'SDFBox',
				type: 'float',
				inputs: [
					{ name: 'p', type: 'vec2' },
					{ name: 'dims', type: 'vec2' }
				]
			} );
			

			const SDFEquilateralTriangle = Fn( ( [ position, r, offset ] ) => {

				const p = position.toVar();
				p.addAssign( offset );
				const k = sqrt( 3.0 );
				p.x.assign( abs( p.x ).sub( r ) );
				p.y.assign( p.y.add( r.div( k ) ) );
				If( p.x.add( k.mul( p.y ) ).greaterThan( 0.0 ), () => {

					const x = p.x.sub( k.mul( p.y ) );
					const y = negate( k ).mul( p.x );
					y.subAssign( p.y );
					p.assign( vec2( x, y ).div( 2.0 ) );

				} );

				p.x.subAssign( clamp( p.x, r.mul( - 2.0 ), 0.0 ) );
				return negate( length( p ).mul( sign( p.y ) ) );

			} ).setLayout( {
				name: 'SDFEquilateralTriangle',
				type: 'float',
				inputs: [
					{ name: 'uvNode', type: 'vec2' },
					{ name: 'radiusNode', type: 'float' },
					{ name: 'offsetNode', type: 'vec2' }
				]
			} );

			const SDFArrow = Fn( ( [ p, velX, velY ] ) => {

				// Add angle in radians between x-axis and velocity vector
				const angle = atan( negate( velY ), negate( velX ) );
				// Set base rotation to allign with x axis
				angle.subAssign( radians( - 90.0 ) );
				// Rotate uv coordinates by angle determined by velocity.
				const uvCellNDCRotated = rotate( p, angle );
				// For some reason uvCellNDCRotated only works for box when it's written inline
				const boxSDF = SDFBox( rotate( p, angle ), vec2( 0.05, 0.6 ) );
				const triangleSDF = SDFEquilateralTriangle( uvCellNDCRotated, float( 0.2 ), vec2( 0.0, - 0.5 ) );
				// Combine box and triangle into arrow
				return min( boxSDF, triangleSDF );

			} ).setLayout( {
				name: 'SDFArrow',
				type: 'float',
				inputs: [
					{ name: 'p', type: 'vec2' },
					{ name: 'velX', type: 'float' },
					{ name: 'velY', type: 'float' }
				]
			} );

			const createColorOutputTSL = ( r, g, b ) => Fn( () => {

				return vec3( r, g, b );

			} );

			// Scene setup utils

			const switchScene = ( sceneIndex ) => {

				currentSceneIndex = sceneIndex;

				if ( sceneIndex === SCENE_DIVERGENCE_PLAYGROUND ) {

					infoCurrentScene = infoDivergencePlayground;
					currentScene = sceneDivergencePlayground;

				} else {

					infoCurrentScene = infoWindTunnel;
					currentScene = sceneWindTunnel;

				}

				// Reassign global uniforms based on current scene
				uSimCols.value = infoCurrentScene.simCols;
				uSimRows.value = infoCurrentScene.simRows;
				uBufferCols.value = infoCurrentScene.bufferCols;
				uBufferRows.value = infoCurrentScene.bufferRows;

			};

			const setupSceneDivergencePlayground = () => {

				// Constants specific to divergence playground
				const outflowIndicatorMaxRadius = 0.5;
				const maximumVelocity = 4.0;

				// Calculate proper cell height
				const res = 20;
				const h = domainHeight / res;

				// Get proper buffer grid and simulation grid dimensions
				const { simCols, simRows } = getSimGridDimensions( h );
				const { bufferCols, bufferRows } = getBufferGridDimensions( simCols, simRows, 1 );

				// Create scene info template, which gets filled out as we initialize this scene
				infoDivergencePlayground = {
					simCols: simCols,
					simRows: simRows,
					numSimCells: simCols * simRows,
					bufferCols: bufferCols,
					bufferRows: bufferRows,
					numBufferCells: bufferCols * bufferRows,
				};

				// Scene specific uniforms
				const uSelectSimCell = uniform( 13 );

				// Scene specific Web API events
				canvas.addEventListener( 'mousemove', ( event ) => {

					const cellWidth = canvas.clientWidth / simCols;
					const cellHeight = canvas.clientHeight / simRows;
					const cellX = Math.floor( event.clientX / cellWidth );
					const cellY = Math.floor( ( canvas.clientHeight - event.clientY ) / cellHeight );

					const cellBufferX = cellX + 1;
					const cellBufferY = cellY + 1;
					const cellIndex = cellBufferX + cellBufferY * bufferCols;
					uSelectSimCell.value = cellIndex;

				} );
			
				const createBufferAttribute = () => new THREE.StorageBufferAttribute( infoDivergencePlayground.numBufferCells, 1 );

				// Create buffers for compute calculations
				const velXBufferAttribute = createBufferAttribute();
				const velYBufferAttribute = createBufferAttribute();
				const pressureBufferAttribute = createBufferAttribute();
				const scalarBufferAttribute = createBufferAttribute();

				const correctSingleCellDivergence = Fn( () => {

					const velXReadWrite = storage( velXBufferAttribute, 'float', infoDivergencePlayground.numBufferCells );
					const velYReadWrite = storage( velYBufferAttribute, 'float', infoDivergencePlayground.numBufferCells );
					const scalarReadWrite = storage( scalarBufferAttribute, 'uint', infoDivergencePlayground.numBufferCells );
					const pressureReadWrite = storage( pressureBufferAttribute, 'float', infoDivergencePlayground.numBufferCells );

					correctCellDivergenceTSL( velXReadWrite, velYReadWrite, scalarReadWrite, pressureReadWrite, uSelectSimCell );

				} )().compute( 1 );

				canvas.addEventListener( 'click', ( event ) => {

					for ( const projectionShader of infoDivergencePlayground.computeProjection ) {

						renderer.compute( projectionShader );

					}

				} );

				// Make all cells obstacle
				scalarBufferAttribute.array.fill( 0 );
			
				// Randomize velocity values
				for ( let i = 0; i < infoDivergencePlayground.numSimCells; i ++ ) {

					const cellIndex = getBufferCellIndexFromSimIndex( i, simCols, bufferCols );
					velXBufferAttribute.array[ cellIndex ] = Math.floor( Math.random() * ( maximumVelocity * 2 ) - maximumVelocity );
					velYBufferAttribute.array[ cellIndex ] = Math.floor( Math.random() * ( maximumVelocity * 2 ) - maximumVelocity );
					// Indicate that cell is sim cell and not obstacle cell.
					scalarBufferAttribute.array[ cellIndex ] = 1;

				}

				// Create Compute Shaders
				createProjectionComputeShaders( velXBufferAttribute, velYBufferAttribute, pressureBufferAttribute, scalarBufferAttribute, infoDivergencePlayground );
				infoDivergencePlayground[ 'Run Divergence Step' ] = () => {
			
					for ( const projectionShader of infoDivergencePlayground.computeProjection ) {

						renderer.compute( projectionShader );

					}

				};

				// Create visualizer
				sceneDivergencePlayground = new THREE.Scene();

				const quadWidth = 2 / simCols;
				const quadHeight = 2 / simRows;

				//const geometry = new THREE.PlaneGeometry(quadWidth, quadHeight);
				const geometry = new THREE.PlaneGeometry( 2, 2 );

				const textureLoader = new THREE.TextureLoader();
				const waterTexture = textureLoader.load( 'textures/water/WaterTexture.png' );
				waterTexture.wrapS = THREE.RepeatWrapping;
				waterTexture.wrapT = THREE.RepeatWrapping;
			
				// Create color constants
				const white = vec4( 1.0, 1.0, 1.0, 1.0 );
				const green = vec4( 0.0, 1.0, 0.0, 1.0 );
				const black = vec4( 0.0, 0.0, 0.0, 1.0 );
			
				const divergenceFragmentNode = Fn( () => {

					const velXRead = storage( velXBufferAttribute, 'float', infoDivergencePlayground.numBufferCells ).toReadOnly();
					const velYRead = storage( velYBufferAttribute, 'float', infoDivergencePlayground.numBufferCells ).toReadOnly();

					const uvGrid = uv().mul( vec2( uSimCols, uSimRows ) ).toVar( 'uvGridNode' );
					// 2D Coordinate in Simulation Grid
					const simGrid2DIndex = floor( uvGrid ).toVar( 'simGrid2DIndex' );
					// 2D Coordinate in Buffer Grid
					const bufferGrid2DIndex = simGrid2DIndex.add( 1 ).toVar( 'bufferGrid2DIndex' );
					// 1D Coordinate in Buffer Grid
					const cellIndex = bufferGrid2DIndex.x.add( bufferGrid2DIndex.y.mul( bufferCols ) ).toVar( 'cellIndex' );

					// Note: Calculate divergence value with actual value from buffers
					// Negate velX and velY to move cell and rotate arrow in proper direction (+x goes right +y goes up)
					const velX = velXRead.element( cellIndex );
					const velY = velYRead.element( cellIndex );
					// Since velocities are constantly changing, we need to reed them from the velocity storage buffers
					const outflow = calculateCellOutflowTSL( velXRead, velYRead, cellIndex, cellIndex.add( 1 ), cellIndex.add( uBufferCols ) );

					const samplePoint = vec2(
						fract( uvGrid.x.add( time.mul( negate( velX ) ) ) ),
						fract( uvGrid.y.add( time.mul( negate( velY ) ) ) )
					).toVar( 'samplePoint' );


					// Get 0 to 1 uv coordinates of each cell
					const uvCell = fract( uvGrid );
					// Get -1 to 1 uv coordinates of each cell
					const uvCellNDC = uvCell.mul( 2.0 ).sub( 1.0 );

					const arrowSDF = SDFArrow( uvCellNDC, velX, velY );

					// Apply circle SDF with radius defined by the outflow
					// Put outflow in range of -1 to 1. The maximum outflow is maxVelocityX + maxVelocityY. The minimumn outflow is the inverse of the maximumn (i.e everything flowing in or everything flowing out)
					const normalizedOutflow = outflow.div( maximumVelocity * 2 ).toVar( 'normalizedOutflow' );
					const circleRadius = float( outflowIndicatorMaxRadius ).mul( abs( normalizedOutflow ) );

					const circleSDF = min( SDFCircle( uvCellNDC, circleRadius ), 0.01 ).toVar( 'circleSDF' );
					const circleCheck = circleSDF.lessThan( 0.0 ).toVar( 'circleCheck' );
					const textureColor = texture( waterTexture, samplePoint ).toVar( 'textureColor' );

					// When outflow is positive, show green, else show black.
					const circleColor = normalizedOutflow.lessThan( 0.0 ).select( black, green ).toVar( 'circleColor' );

					// Apply outflow indicator to color (green for outflow/production, black for inflow/destruction)
					textureColor.x.assign( mix( textureColor.x, circleColor.x, circleCheck ) );
					textureColor.y.assign( mix( textureColor.y, circleColor.y, circleCheck ) );
					textureColor.z.assign( mix( textureColor.z, circleColor.z, circleCheck ) );

					textureColor.assign( mix( white, textureColor, smoothstep( 0.0, 0.02, arrowSDF ) ) );

					// Apply Border on highlight
					const isCellHighlighted = cellIndex.equal( uSelectSimCell ).toVar( 'isCellHighlighted' );
					const borderColor = GetBorder( uvCell, 0.03 ).mul( isCellHighlighted );
					const finalColor = mix( textureColor.rgb, borderColor, max( borderColor.r, max( borderColor.g, borderColor.b ) ) );
			
					return finalColor;
			
				} );

				const nodeMaterial = new THREE.MeshBasicNodeMaterial();
				nodeMaterial.colorNode = divergenceFragmentNode();
				const mesh = new THREE.Mesh( geometry, nodeMaterial );

				sceneDivergencePlayground.add( mesh );

			};

			const setupSceneWindTunnel = () => {

				// Set resolution and determine grid cell height based on resolution
				const res = 200;
				const h = domainHeight / res;

				// Get wind tunnel buffer grid and simulation grid dimensions
				const { simCols, simRows } = getSimGridDimensions( h );
				const { bufferCols, bufferRows } = getBufferGridDimensions( simCols, simRows, 1 );

				infoWindTunnel = {
					simCols: simCols,
					simRows: simRows,
					numSimCells: simCols * simRows,
					bufferCols: bufferCols,
					bufferRows: bufferRows,
					numBufferCells: bufferCols * bufferRows,
				};

				// Create buffers and uniforms specific to wind tunnel simulation
				const velXBufferAttribute = new THREE.StorageBufferAttribute( infoWindTunnel.numBufferCells, 1 );
				const velXStorage = storage( velXBufferAttribute, 'float', infoWindTunnel.numBufferCells );
				const velYBufferAttribute = new THREE.StorageBufferAttribute( infoWindTunnel.numBufferCells, 1 );
				const velYStorage = storage( velYBufferAttribute, 'float', infoWindTunnel.numBufferCells );
				const pressureBufferAttribute = new THREE.StorageBufferAttribute( infoWindTunnel.numBufferCells, 1 );
				const pressureStorage = storage( pressureBufferAttribute, 'float', infoWindTunnel.numBufferCells );
				const scalarBufferAttribute = new THREE.StorageBufferAttribute( infoWindTunnel.numBufferCells, 1 );
				const scalarStorage = storage( scalarBufferAttribute, 'uint', infoWindTunnel.numBufferCells );

				const uOverRelaxation = uniform( 1.9 );
				const uCP = uniform( 1000 );
				const uDensity = uniform( 1000 );
				const uGravity = uniform( - 9.81 );

				infoWindTunnel.computeIntegration = Fn( () => {

					const velYWriteBuffer = storage( velYBufferAttribute, 'float', infoWindTunnel.numBufferCells );
					const cellIndex = GetBufferCellIndexFromSimIndex( instanceIndex, uSimCols, uBufferCols );
					velYWriteBuffer.element( cellIndex ).addAssign( uGravity.mul( time ) );

				} )().compute( infoWindTunnel.numSimCells );

				createProjectionComputeShaders( velXBufferAttribute, velYBufferAttribute, pressureBufferAttribute, scalarBufferAttribute, infoWindTunnel );

				// Extrapolate velocity of buffer cells from surrounding simulation cells.
				// Effectively a post-processing part of the divergence/outflow/incompressibility step.
				// Shader is a bit of hack, making use of the fact that our grid dimensions are always square.
				infoWindTunnel.computeExtrapolateX = Fn( () => {

					const velXReadWrite = storage( velXBufferAttribute, 'float', 1 );

					// Buffer cell to left of first simulation column
					const cellLeftBufferIndex = instanceIndex.mul( bufferCols );
					// Buffer cell to right of last simulation column
					const cellRightBufferIndex = cellLeftBufferIndex.add( bufferCols - 1 );

					// Apply horizontal velocity of simulation cells to left and right buffer cells
					const leftBufferVelocity = velXReadWrite.element( cellLeftBufferIndex );
					leftBufferVelocity.assign( velXReadWrite.element( cellLeftBufferIndex.add( 1 ) ) );

					const rightBufferVelocity = velXReadWrite.element( cellRightBufferIndex );
					rightBufferVelocity.assign( velXReadWrite.element( cellRightBufferIndex.sub( 1 ) ) );

				} )().compute( bufferRows );

				infoWindTunnel.computeExtrapolateY = Fn( () => {

					const velYReadWrite = storage( velYBufferAttribute, 'float', 1 );

					// Buffer cell below first simulation row
					const cellBottomBufferIndex = instanceIndex;
					// Buffer cell above last simulation row
					const cellTopBufferIndex = instanceIndex.add( bufferCols * bufferRows - 1 );

					// Apply vertical velocity of simulation cells to top and bottom buffer cells
					const bottomBufferVelocity = velYReadWrite.element( cellBottomBufferIndex );
					bottomBufferVelocity.assign( velYReadWrite.element( cellBottomBufferIndex.add( 1 ) ) );

					const topBufferVelocity = velYReadWrite.element( cellTopBufferIndex );
					topBufferVelocity.assign( velYReadWrite.element( cellTopBufferIndex.sub( 1 ) ) );

				} )().compute( bufferCols );


				// Advect u
				infoWindTunnel.computeAdvectFluidX = Fn( () => {
			
					const scalarStorage = storage( scalarBufferAttribute, 'uint', infoWindTunnel.numBufferCells );

					const cellIndex = GetBufferCellIndexFromSimIndex( uSimCols + 1, uBufferCols );

					const scalarCell = scalarStorage.element( cellIndex );
					const scalarCellLeft = scalarStorage.element( cellIndex.sub( 1 ) );

					// If there is nowhere for the velocity to advect frokm
					If( scalarCell.equal( 0.0 ).or( scalarCellLeft.equal( 0.0 ) ), () => {

						Return();

					} );

					const x = float( 1.0 );
					const y = float( 1.0 );

					const velX = velXStorage.element( cellIndex );
					const velY = averageVelocityYTSL( velYStorage, cellIndex );
					x.subAssign( velX.mul( timerDelta() ) );
					y.subAssign( velY.mul( timerDelta() ) );

					velX.assign( sampleFieldTSL( U_FIELD, velXStorage ) );





				} )().compute( ( infoWindTunnel.simCols + 1 ) * infoWindTunnel.simRows );

				infoWindTunnel.computeAdvectFluidY;

				infoWindTunnel.computeAdvectSmoke = Fn( () => {

					const velXStorage = storage( velXBufferAttribute, 'float', 1 );
					const velYStorage = storage( velYBufferAttribute, 'float', 1 );
					const cellIndex = GetBufferCellIndexFromSimIndex( uSimCols, uBufferCols );

					const velX = velXStorage.element( cellIndex );
					const velXRight = velXStorage.element( cellIndex.add( 1 ) );
					const newX = float( 0.5 ).mul( velX.add( velXRight ) );
			
					const velY = velYStorage.element( cellIndex );
					const velYUp = velYStorage.element( cellIndex + uBufferCols );
					const newY = float( 0.5 ).mul( velY.add( velYUp ) );

				} )().compute( infoWindTunnel.numSimCells );

				const returnColor = ( r, g, b ) => {

					return vec3( r, g, b );
			
	};

				const fs = createColorOutputTSL( 1.0, 0.0, 0.0 );

				sceneWindTunnel = new THREE.Scene();

				const geometry = new THREE.PlaneGeometry( 2, 2 );

				const simWithStorageQuad = new THREE.Mesh( geometry, new THREE.MeshBasicNodeMaterial( {
					colorNode: fs(),
				} ) );
				sceneWindTunnel.add( simWithStorageQuad );

			};

			function init() {
			
				// Create renderer
				renderer = new THREE.WebGPURenderer( { antialias: true, canvas: canvas } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				document.body.appendChild( renderer.domElement );
				window.addEventListener( 'resize', onWindowResize );

				// For now try to use same camera for each scene
				camera = new THREE.OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );

				// Create simulation height
				simHeight = 1.0;
				cScale = canvas.height / simHeight;
				simWidth = canvas.width / cScale;
				domainHeight = 1.0;
				domainWidth = domainHeight / simHeight * simWidth;

				uSimCols = uniform( 0 );
				uSimRows = uniform( 0 );
				uBufferCols = uniform( 0 );
				uBufferRows = uniform( 0 );
				uOverRelaxation = uniform( 1.0 );

				setupSceneDivergencePlayground();
				setupSceneWindTunnel();
			
				switchScene( SCENE_DIVERGENCE_PLAYGROUND );

				settings = {
					'Projection Iterations': 40,
					'Current Scene': 'Divergence Playground',
				};

				const gui = new GUI();

				const simulationFolder = gui.addFolder( 'Simulation' );
				simulationFolder.add( settings, 'Current Scene', [ 'Divergence Playground', 'Wind Tunnel' ] ).onChange( () => {

					switchScene( sceneEnum[ settings[ 'Current Scene' ] ] );
			
	} );
				simulationFolder.add( settings, 'Projection Iterations', 1, 100 ).step( 1 );
				simulationFolder.add( uOverRelaxation, 'value', 1.0, 1.9 ).step( 0.1 ).name( 'Over Relaxation' );

				const divergencePlaygroundFolder = gui.addFolder( 'Divergence Playground' );
				divergencePlaygroundFolder.add( infoDivergencePlayground, 'Run Divergence Step' );

				const windTunnelFolder = gui.addFolder( 'Wind Tunnel' );


				renderer.setAnimationLoop( animate );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function animate() {

				// Apply external forces ( gravity, outside actors, etc. ) to velocity
				if ( infoCurrentScene.computeIntegration ) {

					renderer.compute( infoCurrentScene.computeIntegration );

				}

				// Compute divergence of each cell and project surrounding velocities
				if ( infoCurrentScene.computeProjection && currentSceneIndex !== SCENE_DIVERGENCE_PLAYGROUND ) {

					for ( let i = 0; i < settings[ 'Projection Iterations' ]; i ++ ) {

						for ( const projectionShader of infoCurrentScene.computeProjection ) {

							renderer.compute( projectionShader );

						}
			
					}

				}

				// Extrapolate velocities of buffer cells in each column
				if ( infoCurrentScene.computeExtrapolateX ) {

					renderer.compute( infoCurrentScene.computeExtrapolateX );

				}

				// Extrapolate velocities of buffer cells in each row
				if ( infoCurrentScene.computeExtrapolateY ) {

					renderer.compute( infoCurrentScene.computeExtrapolateY );

				}

				// Advect Fluid
				if ( infoCurrentScene.computeAdvectFluid ) {

					renderer.compute( infoCurrentScene.computeAdvectFluid );

				}

				// Advect Smoke
				if ( infoCurrentScene.computeAdvectSmoke ) {

					renderer.compute( infoCurrentScene.computeAdvectSmoke );

				}

				renderer.render( currentScene, camera );

			}

			init();

		</script>
	</body>
</html>